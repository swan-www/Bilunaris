// auto generated by c2z
const std = @import("std");
//const cpp = @import("cpp");
const FileMode = @import("../Interfaces/IFileSystem.zig").FileMode;

/// If you add more levels don't forget to change LOG_LEVELS macro to the actual number of levels
pub const LogLevel = extern struct {
    bits: c_int = 0,

    pub const eNONE: LogLevel = .{ .bits = 0 };
    pub const eRAW: LogLevel = .{ .bits = 1 };
    pub const eDEBUG: LogLevel = .{ .bits = 2 };
    pub const eINFO: LogLevel = .{ .bits = 4 };
    pub const eWARNING: LogLevel = .{ .bits = 8 };
    pub const eERROR: LogLevel = .{ .bits = 16 };
    pub const eALL: LogLevel = .{ .bits = -1 };

    // pub usingnamespace cpp.FlagsMixin(LogLevel);
};

/// If you add more levels don't forget to change LOG_LEVELS macro to the actual number of levels
pub const LogCallbackFn = ?*const fn (?*anyopaque, [*c]const u8) callconv(.C) void;

pub const LogCloseFn = ?*const fn (?*anyopaque) callconv(.C) void;

pub const LogFlushFn = ?*const fn (?*anyopaque) callconv(.C) void;

/// Initialization/Exit functions are thread unsafe
/// appName   used to create appName.log. Pass NULL to disable
/// level     mask of LogLevel bits. Log is ignored if its level is missing in mask. Use eALL to enable full log
extern fn _1_initLog_(appName: [*c]const u8, level: LogLevel) void;
pub fn initLog(appName: [*c]const u8, level: LogLevel) void {
    _1_initLog_(appName, level);
}

extern fn _1_exitLog_() void;
pub fn exitLog() void {
    _1_exitLog_();
}

extern fn _1_addLogFile_(filename: [*c]const u8, file_mode: FileMode, log_level: LogLevel) void;
pub const addLogFile = _1_addLogFile_;

extern fn _1_addLogCallback_(id: [*c]const u8, log_level: u32, user_data: ?*anyopaque, callback: LogCallbackFn, close: LogCloseFn, flush: LogFlushFn) void;
pub const addLogCallback = _1_addLogCallback_;

extern fn _1_writeLogVaList_(level: u32, filename: [*c]const u8, line_number: c_int, message: [*c]const u8, args: [*c]u8) void;
pub const writeLogVaList = _1_writeLogVaList_;

/// Usage:
/// puts(humanReadableTime(ns).str);
/// printf("%s\n", humanReadableTime(ms * 1000).str);
/// humanReadableSize(9238412498).str;
pub const HumanReadableValue = extern struct {
    str: [16]u8,
};

extern fn _1_humanReadableSSize_(size: isize) HumanReadableValue;
pub const humanReadableSSize = _1_humanReadableSSize_;

extern fn _1_humanReadableTimeD_(nanoseconds: f64) HumanReadableValue;
pub const humanReadableTimeD = _1_humanReadableTimeD_;

pub inline fn humanReadableSize(size: usize) HumanReadableValue {
    return humanReadableSSize(@as(isize, @intCast(size)));
}
pub inline fn humanReadableTime(nanoseconds: i64) HumanReadableValue {
    return humanReadableTimeD(@floatFromInt(nanoseconds));
}
