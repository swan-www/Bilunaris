// auto generated by c2z
const std = @import("std");
//const cpp = @import("cpp");

pub const TinyImageFormat = @import("TinyImageFormat.zig").TinyImageFormat;
const gpu_cmd_ring = @import("GpuCmdRing.zig");
pub const GpuCmdRing = gpu_cmd_ring.GpuCmdRing;
pub const GpuCmdRingElememnt = gpu_cmd_ring.GpuCmdRingElement;
pub const GpuCmdRingDesc = gpu_cmd_ring.GpuCmdRingDesc;

/// Taken from IOperatingSystem.h
pub const ReloadType = packed struct(u32) {
    RESIZE: bool = false, // 0x1
    SHADER: bool = false, // 0x2
    RENDERTARGET: bool = false, // 0x4,
    __unused: u28 = 0,
    ALL: bool = false, // 0xffffffff

    pub const RESIZE_RENDERTARGET = ReloadType{
        .RESIZE = true,
        .RENDERTARGET = true,
    };

    pub const RESIZE_SHADER_RENDERTARGET = ReloadType{
        .RESIZE = true,
        .SHADER = true,
        .RENDERTARGET = true,
    };
};

pub const ReloadDesc = struct {
    mType: ReloadType,
};

// NOTE(gmodarelli): I've only manually written the bindings for Win32
pub const WindowHandle = extern struct {
    type: WindowHandleType,
    window: std.os.windows.HWND,
};

pub const WindowHandleType = enum(u32) {
    UNKNOWN,
    WIN32,
    XLIB,
    XCB,
    WAYLAND,
    ANDROID,
    VI_NN,
};

/// D3D structs definitions copied from zig-gamdev/zwin32/d3dcommon.zig
pub const D3D_PRIMITIVE_TOPOLOGY = enum(u32) {
    D3D_PRIMITIVE_TOPOLOGY_UNDEFINED = 0,
    D3D_PRIMITIVE_TOPOLOGY_POINTLIST = 1,
    D3D_PRIMITIVE_TOPOLOGY_LINELIST = 2,
    D3D_PRIMITIVE_TOPOLOGY_LINESTRIP = 3,
    D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST = 4,
    D3D_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP = 5,
    D3D_PRIMITIVE_TOPOLOGY_LINELIST_ADJ = 10,
    D3D_PRIMITIVE_TOPOLOGY_LINESTRIP_ADJ = 11,
    D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST_ADJ = 12,
    D3D_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP_ADJ = 13,
    D3D_PRIMITIVE_TOPOLOGY_CONTROL_POINT_PATCHLIST = 33,
    D3D_PRIMITIVE_TOPOLOTY_2_CONTROL_POINT_PATCHLIST = 34,
    D3D_PRIMITIVE_TOPOLOTY_3_CONTROL_POINT_PATCHLIST = 35,
    D3D_PRIMITIVE_TOPOLOTY_4_CONTROL_POINT_PATCHLIST = 36,
    D3D_PRIMITIVE_TOPOLOTY_5_CONTROL_POINT_PATCHLIST = 37,
    D3D_PRIMITIVE_TOPOLOTY_6_CONTROL_POINT_PATCHLIST = 38,
    D3D_PRIMITIVE_TOPOLOTY_7_CONTROL_POINT_PATCHLIST = 39,
    D3D_PRIMITIVE_TOPOLOTY_8_CONTROL_POINT_PATCHLIST = 40,
    D3D_PRIMITIVE_TOPOLOTY_9_CONTROL_POINT_PATCHLIST = 41,
    D3D_PRIMITIVE_TOPOLOTY_10_CONTROL_POINT_PATCHLIST = 42,
    D3D_PRIMITIVE_TOPOLOTY_11_CONTROL_POINT_PATCHLIST = 43,
    D3D_PRIMITIVE_TOPOLOTY_12_CONTROL_POINT_PATCHLIST = 44,
    D3D_PRIMITIVE_TOPOLOTY_13_CONTROL_POINT_PATCHLIST = 45,
    D3D_PRIMITIVE_TOPOLOTY_14_CONTROL_POINT_PATCHLIST = 46,
    D3D_PRIMITIVE_TOPOLOTY_15_CONTROL_POINT_PATCHLIST = 47,
    D3D_PRIMITIVE_TOPOLOTY_16_CONTROL_POINT_PATCHLIST = 48,
    D3D_PRIMITIVE_TOPOLOTY_17_CONTROL_POINT_PATCHLIST = 49,
    D3D_PRIMITIVE_TOPOLOTY_18_CONTROL_POINT_PATCHLIST = 50,
    D3D_PRIMITIVE_TOPOLOTY_19_CONTROL_POINT_PATCHLIST = 51,
    D3D_PRIMITIVE_TOPOLOTY_20_CONTROL_POINT_PATCHLIST = 52,
    D3D_PRIMITIVE_TOPOLOTY_21_CONTROL_POINT_PATCHLIST = 53,
    D3D_PRIMITIVE_TOPOLOTY_22_CONTROL_POINT_PATCHLIST = 54,
    D3D_PRIMITIVE_TOPOLOTY_23_CONTROL_POINT_PATCHLIST = 55,
    D3D_PRIMITIVE_TOPOLOTY_24_CONTROL_POINT_PATCHLIST = 56,
    D3D_PRIMITIVE_TOPOLOTY_25_CONTROL_POINT_PATCHLIST = 57,
    D3D_PRIMITIVE_TOPOLOTY_26_CONTROL_POINT_PATCHLIST = 58,
    D3D_PRIMITIVE_TOPOLOTY_27_CONTROL_POINT_PATCHLIST = 59,
    D3D_PRIMITIVE_TOPOLOTY_28_CONTROL_POINT_PATCHLIST = 60,
    D3D_PRIMITIVE_TOPOLOTY_29_CONTROL_POINT_PATCHLIST = 61,
    D3D_PRIMITIVE_TOPOLOTY_30_CONTROL_POINT_PATCHLIST = 62,
    D3D_PRIMITIVE_TOPOLOTY_31_CONTROL_POINT_PATCHLIST = 63,
    D3D_PRIMITIVE_TOPOLOTY_32_CONTROL_POINT_PATCHLIST = 64,
};

/// D3D12 structs definitions copied from zig-gamdev/zwin32/d3d12.zig
pub const D3D12_SAMPLER_DESC = extern struct {
    Filter: D3D12_FILTER,
    AddressU: D3D12_TEXTURE_ADDRESS_MODE,
    AddressV: D3D12_TEXTURE_ADDRESS_MODE,
    AddressW: D3D12_TEXTURE_ADDRESS_MODE,
    MipLODBias: f32,
    MaxAnisotropy: u32,
    ComparisonFunc: D3D12_COMPARISON_FUNC,
    BorderColor: [4]f32,
    MinLOD: f32,
    MaxLOD: f32,
};

pub const D3D12_FILTER = enum(u32) {
    MIN_MAG_MIP_POINT = 0,
    MIN_MAG_POINT_MIP_LINEAR = 0x1,
    MIN_POINT_MAG_LINEAR_MIP_POINT = 0x4,
    MIN_POINT_MAG_MIP_LINEAR = 0x5,
    MIN_LINEAR_MAG_MIP_POINT = 0x10,
    MIN_LINEAR_MAG_POINT_MIP_LINEAR = 0x11,
    MIN_MAG_LINEAR_MIP_POINT = 0x14,
    MIN_MAG_MIP_LINEAR = 0x15,
    ANISOTROPIC = 0x55,
    COMPARISON_MIN_MAG_MIP_POINT = 0x80,
    COMPARISON_MIN_MAG_POINT_MIP_LINEAR = 0x81,
    COMPARISON_MIN_POINT_MAG_LINEAR_MIP_POINT = 0x84,
    COMPARISON_MIN_POINT_MAG_MIP_LINEAR = 0x85,
    COMPARISON_MIN_LINEAR_MAG_MIP_POINT = 0x90,
    COMPARISON_MIN_LINEAR_MAG_POINT_MIP_LINEAR = 0x91,
    COMPARISON_MIN_MAG_LINEAR_MIP_POINT = 0x94,
    COMPARISON_MIN_MAG_MIP_LINEAR = 0x95,
    COMPARISON_ANISOTROPIC = 0xd5,
    MINIMUM_MIN_MAG_MIP_POINT = 0x100,
    MINIMUM_MIN_MAG_POINT_MIP_LINEAR = 0x101,
    MINIMUM_MIN_POINT_MAG_LINEAR_MIP_POINT = 0x104,
    MINIMUM_MIN_POINT_MAG_MIP_LINEAR = 0x105,
    MINIMUM_MIN_LINEAR_MAG_MIP_POINT = 0x110,
    MINIMUM_MIN_LINEAR_MAG_POINT_MIP_LINEAR = 0x111,
    MINIMUM_MIN_MAG_LINEAR_MIP_POINT = 0x114,
    MINIMUM_MIN_MAG_MIP_LINEAR = 0x115,
    MINIMUM_ANISOTROPIC = 0x155,
    MAXIMUM_MIN_MAG_MIP_POINT = 0x180,
    MAXIMUM_MIN_MAG_POINT_MIP_LINEAR = 0x181,
    MAXIMUM_MIN_POINT_MAG_LINEAR_MIP_POINT = 0x184,
    MAXIMUM_MIN_POINT_MAG_MIP_LINEAR = 0x185,
    MAXIMUM_MIN_LINEAR_MAG_MIP_POINT = 0x190,
    MAXIMUM_MIN_LINEAR_MAG_POINT_MIP_LINEAR = 0x191,
    MAXIMUM_MIN_MAG_LINEAR_MIP_POINT = 0x194,
    MAXIMUM_MIN_MAG_MIP_LINEAR = 0x195,
    MAXIMUM_ANISOTROPIC = 0x1d5,
};

pub const D3D12_TEXTURE_ADDRESS_MODE = enum(u32) {
    WRAP = 1,
    MIRROR = 2,
    CLAMP = 3,
    BORDER = 4,
    MIRROR_ONCE = 5,
};

pub const D3D12_COMPARISON_FUNC = enum(u32) {
    NEVER = 1,
    LESS = 2,
    EQUAL = 3,
    LESS_EQUAL = 4,
    GREATER = 5,
    NOT_EQUAL = 6,
    GREATER_EQUAL = 7,
    ALWAYS = 8,
};

/// Forward declare opaque memory allocator structs
pub const DxDescriptorID = i32;

const D3D_FEATURE_LEVEL = u32;
const D3D12_GPU_DESCRIPTOR_HANDLE = anyopaque;
const D3D12_GPU_VIRTUAL_ADDRESS = u64;
const D3D12_QUERY_TYPE = u32;
const DescriptorHeap = anyopaque;
const HANDLE = *anyopaque;
const ID3D12CommandAllocator = anyopaque;
const ID3D12CommandQueue = anyopaque;
const ID3D12CommandSignature = anyopaque;
const ID3D12Debug = anyopaque;
const ID3D12Device = anyopaque;
const ID3D12Fence = anyopaque;
const ID3D12GraphicsCommandList1 = anyopaque;
const ID3D12Heap = anyopaque;
const ID3D12InfoQueue = anyopaque;
const ID3D12PipelineLibrary = anyopaque;
const ID3D12PipelineState = anyopaque;
const ID3D12QueryHeap = anyopaque;
const ID3D12Resource = anyopaque;
const ID3D12RootSignature = anyopaque;
const IDxcBlobEncoding = anyopaque;
const IDXGIAdapter4 = anyopaque;
const IDXGIFactory6 = anyopaque;
const IDXGISwapChain3 = anyopaque;
const LogLevel = u32;
const LPCWSTR = *anyopaque;
const PipelineReflection = anyopaque;

pub const RendererApi = extern struct {
    bits: c_int = 0,

    pub const RENDERER_API_D3D12: RendererApi = .{ .bits = 0 };
    pub const RENDERER_API_COUNT: RendererApi = .{ .bits = 1 };

    // pub usingnamespace cpp.FlagsMixin(RendererApi);
};

pub const QueueType = extern struct {
    bits: c_int = 0,

    pub const QUEUE_TYPE_GRAPHICS: QueueType = .{ .bits = @as(c_uint, @intCast(0)) };
    pub const QUEUE_TYPE_TRANSFER: QueueType = .{ .bits = QueueType.QUEUE_TYPE_GRAPHICS.bits + 1 };
    pub const QUEUE_TYPE_COMPUTE: QueueType = .{ .bits = QueueType.QUEUE_TYPE_GRAPHICS.bits + 2 };
    pub const MAX_QUEUE_TYPE: QueueType = .{ .bits = QueueType.QUEUE_TYPE_GRAPHICS.bits + 3 };

    // pub usingnamespace cpp.FlagsMixin(QueueType);
};

pub const QueueFlag = extern struct {
    bits: c_int = 0,

    pub const QUEUE_FLAG_NONE: QueueFlag = .{ .bits = @as(c_uint, @intCast(0)) };
    pub const QUEUE_FLAG_DISABLE_GPU_TIMEOUT: QueueFlag = .{ .bits = @as(c_uint, @intCast(1)) };
    pub const QUEUE_FLAG_INIT_MICROPROFILE: QueueFlag = .{ .bits = @as(c_uint, @intCast(2)) };
    pub const MAX_QUEUE_FLAG: QueueFlag = .{ .bits = 4294967295 };

    // pub usingnamespace cpp.FlagsMixin(QueueFlag);
};

pub const QueuePriority = extern struct {
    bits: c_int = 0,

    pub const QUEUE_PRIORITY_NORMAL: QueuePriority = .{ .bits = 0 };
    pub const QUEUE_PRIORITY_HIGH: QueuePriority = .{ .bits = 1 };
    pub const QUEUE_PRIORITY_GLOBAL_REALTIME: QueuePriority = .{ .bits = 2 };
    pub const MAX_QUEUE_PRIORITY: QueuePriority = .{ .bits = 3 };

    // pub usingnamespace cpp.FlagsMixin(QueuePriority);
};

pub const LoadActionType = extern struct {
    bits: c_int = 0,

    pub const LOAD_ACTION_DONTCARE: LoadActionType = .{ .bits = 0 };
    pub const LOAD_ACTION_LOAD: LoadActionType = .{ .bits = 1 };
    pub const LOAD_ACTION_CLEAR: LoadActionType = .{ .bits = 2 };
    pub const MAX_LOAD_ACTION: LoadActionType = .{ .bits = 3 };

    // pub usingnamespace cpp.FlagsMixin(LoadActionType);
};

pub const StoreActionType = extern struct {
    bits: c_int = 0,

    /// Store is the most common use case so keep that as default
    pub const STORE_ACTION_STORE: StoreActionType = .{ .bits = 0 };
    /// Store is the most common use case so keep that as default
    pub const STORE_ACTION_DONTCARE: StoreActionType = .{ .bits = 1 };
    /// Store is the most common use case so keep that as default
    pub const STORE_ACTION_NONE: StoreActionType = .{ .bits = 2 };
    pub const MAX_STORE_ACTION: StoreActionType = .{ .bits = 3 };

    // pub usingnamespace cpp.FlagsMixin(StoreActionType);
};

pub const LogFn = ?*const fn (LogLevel, [*c]const u8, [*c]const u8) callconv(.C) void;

pub const ResourceState = extern struct {
    bits: c_int = 0,

    pub const RESOURCE_STATE_UNDEFINED: ResourceState = .{ .bits = @as(c_uint, @intCast(0)) };
    pub const RESOURCE_STATE_VERTEX_AND_CONSTANT_BUFFER: ResourceState = .{ .bits = @as(c_uint, @intCast(1)) };
    pub const RESOURCE_STATE_INDEX_BUFFER: ResourceState = .{ .bits = @as(c_uint, @intCast(2)) };
    pub const RESOURCE_STATE_RENDER_TARGET: ResourceState = .{ .bits = @as(c_uint, @intCast(4)) };
    pub const RESOURCE_STATE_UNORDERED_ACCESS: ResourceState = .{ .bits = @as(c_uint, @intCast(8)) };
    pub const RESOURCE_STATE_DEPTH_WRITE: ResourceState = .{ .bits = @as(c_uint, @intCast(16)) };
    pub const RESOURCE_STATE_DEPTH_READ: ResourceState = .{ .bits = @as(c_uint, @intCast(32)) };
    pub const RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE: ResourceState = .{ .bits = @as(c_uint, @intCast(64)) };
    pub const RESOURCE_STATE_PIXEL_SHADER_RESOURCE: ResourceState = .{ .bits = @as(c_uint, @intCast(128)) };
    pub const RESOURCE_STATE_SHADER_RESOURCE: ResourceState = .{ .bits = @as(c_uint, @intCast(64 | 128)) };
    pub const RESOURCE_STATE_STREAM_OUT: ResourceState = .{ .bits = @as(c_uint, @intCast(256)) };
    pub const RESOURCE_STATE_INDIRECT_ARGUMENT: ResourceState = .{ .bits = @as(c_uint, @intCast(512)) };
    pub const RESOURCE_STATE_COPY_DEST: ResourceState = .{ .bits = @as(c_uint, @intCast(1024)) };
    pub const RESOURCE_STATE_COPY_SOURCE: ResourceState = .{ .bits = @as(c_uint, @intCast(2048)) };
    pub const RESOURCE_STATE_GENERIC_READ: ResourceState = .{ .bits = @as(c_uint, @intCast((((((1 | 2) | 64) | 128) | 512) | 2048))) };
    pub const RESOURCE_STATE_PRESENT: ResourceState = .{ .bits = @as(c_uint, @intCast(4096)) };
    pub const RESOURCE_STATE_COMMON: ResourceState = .{ .bits = @as(c_uint, @intCast(8192)) };
    pub const RESOURCE_STATE_ACCELERATION_STRUCTURE_READ: ResourceState = .{ .bits = @as(c_uint, @intCast(16384)) };
    pub const RESOURCE_STATE_ACCELERATION_STRUCTURE_WRITE: ResourceState = .{ .bits = @as(c_uint, @intCast(32768)) };

    // pub usingnamespace cpp.FlagsMixin(ResourceState);
};

/// Choosing Memory Type
pub const ResourceMemoryUsage = extern struct {
    bits: c_int = 0,

    /// No intended memory usage specified.
    pub const RESOURCE_MEMORY_USAGE_UNKNOWN: ResourceMemoryUsage = .{ .bits = @as(c_uint, @intCast(0)) };
    /// Memory will be used on device only, no need to be mapped on host.
    pub const RESOURCE_MEMORY_USAGE_GPU_ONLY: ResourceMemoryUsage = .{ .bits = @as(c_uint, @intCast(1)) };
    /// Memory will be mapped on host. Could be used for transfer to device.
    pub const RESOURCE_MEMORY_USAGE_CPU_ONLY: ResourceMemoryUsage = .{ .bits = @as(c_uint, @intCast(2)) };
    /// Memory will be used for frequent (dynamic) updates from host and reads on device.
    pub const RESOURCE_MEMORY_USAGE_CPU_TO_GPU: ResourceMemoryUsage = .{ .bits = @as(c_uint, @intCast(3)) };
    /// Memory will be used for writing on device and readback on host.
    pub const RESOURCE_MEMORY_USAGE_GPU_TO_CPU: ResourceMemoryUsage = .{ .bits = @as(c_uint, @intCast(4)) };
    /// Memory will be used for writing on device and readback on host.
    pub const RESOURCE_MEMORY_USAGE_COUNT: ResourceMemoryUsage = .{ .bits = ResourceMemoryUsage.RESOURCE_MEMORY_USAGE_GPU_TO_CPU.bits + 1 };
    /// Memory will be used for writing on device and readback on host.
    pub const RESOURCE_MEMORY_USAGE_MAX_ENUM: ResourceMemoryUsage = .{ .bits = @as(c_uint, @intCast(2147483647)) };

    // pub usingnamespace cpp.FlagsMixin(ResourceMemoryUsage);
};

/// Choosing Memory Type
pub const PlatformParameters = extern struct {
    /// RendererAPI
    mSelectedRendererApi: RendererApi,
    /// Available GPU capabilities
    ppAvailableGpuNames: [256][4]u8,
    pAvailableGpuIds: [4]u32,
    mAvailableGpuCount: u32,
    mSelectedGpuIndex: u32,
    /// Could add swap chain size, render target format, ...
    mPreferedGpuId: u32,
};

/// Forward declarations
/// Raytracing
pub const IndirectDrawArguments = extern struct {
    mVertexCount: u32,
    mInstanceCount: u32,
    mStartVertex: u32,
    mStartInstance: u32,
};

pub const IndirectDrawIndexArguments = extern struct {
    mIndexCount: u32,
    mInstanceCount: u32,
    mStartIndex: u32,
    mVertexOffset: u32,
    mStartInstance: u32,
};

pub const IndirectDispatchArguments = extern struct {
    mGroupCountX: u32,
    mGroupCountY: u32,
    mGroupCountZ: u32,
};

pub const IndirectArgumentType = extern struct {
    bits: c_int = 0,

    pub const INDIRECT_ARG_INVALID: IndirectArgumentType = .{ .bits = 0 };
    pub const INDIRECT_DRAW: IndirectArgumentType = .{ .bits = 1 };
    pub const INDIRECT_DRAW_INDEX: IndirectArgumentType = .{ .bits = 2 };
    pub const INDIRECT_DISPATCH: IndirectArgumentType = .{ .bits = 3 };
    pub const INDIRECT_VERTEX_BUFFER: IndirectArgumentType = .{ .bits = 4 };
    pub const INDIRECT_INDEX_BUFFER: IndirectArgumentType = .{ .bits = 5 };
    pub const INDIRECT_CONSTANT: IndirectArgumentType = .{ .bits = 6 };
    /// only for dx
    pub const INDIRECT_CONSTANT_BUFFER_VIEW: IndirectArgumentType = .{ .bits = 7 };
    /// only for dx
    pub const INDIRECT_SHADER_RESOURCE_VIEW: IndirectArgumentType = .{ .bits = 8 };
    /// only for dx
    pub const INDIRECT_UNORDERED_ACCESS_VIEW: IndirectArgumentType = .{ .bits = 9 };
    /// metal ICB
    pub const INDIRECT_COMMAND_BUFFER: IndirectArgumentType = .{ .bits = 10 };
    /// metal ICB reset
    pub const INDIRECT_COMMAND_BUFFER_RESET: IndirectArgumentType = .{ .bits = 11 };
    /// metal ICB optimization
    pub const INDIRECT_COMMAND_BUFFER_OPTIMIZE: IndirectArgumentType = .{ .bits = 12 };

    // pub usingnamespace cpp.FlagsMixin(IndirectArgumentType);
};

///*********************************************
pub const DescriptorType = extern struct {
    bits: c_int = 0,

    pub const DESCRIPTOR_TYPE_UNDEFINED: DescriptorType = .{ .bits = @as(c_uint, @intCast(0)) };
    pub const DESCRIPTOR_TYPE_SAMPLER: DescriptorType = .{ .bits = @as(c_uint, @intCast(1)) };
    /// SRV Read only texture
    pub const DESCRIPTOR_TYPE_TEXTURE: DescriptorType = .{ .bits = @as(c_uint, @intCast((DescriptorType.DESCRIPTOR_TYPE_SAMPLER.bits << 1))) };
    /// UAV Texture
    pub const DESCRIPTOR_TYPE_RW_TEXTURE: DescriptorType = .{ .bits = @as(c_uint, @intCast((DescriptorType.DESCRIPTOR_TYPE_TEXTURE.bits << 1))) };
    /// SRV Read only buffer
    pub const DESCRIPTOR_TYPE_BUFFER: DescriptorType = .{ .bits = @as(c_uint, @intCast((DescriptorType.DESCRIPTOR_TYPE_RW_TEXTURE.bits << 1))) };
    /// SRV Read only buffer
    pub const DESCRIPTOR_TYPE_BUFFER_RAW: DescriptorType = .{ .bits = @as(c_uint, @intCast((DescriptorType.DESCRIPTOR_TYPE_BUFFER.bits | (DescriptorType.DESCRIPTOR_TYPE_BUFFER.bits << 1)))) };
    /// UAV Buffer
    pub const DESCRIPTOR_TYPE_RW_BUFFER: DescriptorType = .{ .bits = @as(c_uint, @intCast((DescriptorType.DESCRIPTOR_TYPE_BUFFER.bits << 2))) };
    /// UAV Buffer
    pub const DESCRIPTOR_TYPE_RW_BUFFER_RAW: DescriptorType = .{ .bits = @as(c_uint, @intCast((DescriptorType.DESCRIPTOR_TYPE_RW_BUFFER.bits | (DescriptorType.DESCRIPTOR_TYPE_RW_BUFFER.bits << 1)))) };
    /// Uniform buffer
    pub const DESCRIPTOR_TYPE_UNIFORM_BUFFER: DescriptorType = .{ .bits = @as(c_uint, @intCast((DescriptorType.DESCRIPTOR_TYPE_RW_BUFFER.bits << 2))) };
    /// Push constant / Root constant
    pub const DESCRIPTOR_TYPE_ROOT_CONSTANT: DescriptorType = .{ .bits = @as(c_uint, @intCast((DescriptorType.DESCRIPTOR_TYPE_UNIFORM_BUFFER.bits << 1))) };
    /// IA
    pub const DESCRIPTOR_TYPE_VERTEX_BUFFER: DescriptorType = .{ .bits = @as(c_uint, @intCast((DescriptorType.DESCRIPTOR_TYPE_ROOT_CONSTANT.bits << 1))) };
    /// IA
    pub const DESCRIPTOR_TYPE_INDEX_BUFFER: DescriptorType = .{ .bits = @as(c_uint, @intCast((DescriptorType.DESCRIPTOR_TYPE_VERTEX_BUFFER.bits << 1))) };
    /// IA
    pub const DESCRIPTOR_TYPE_INDIRECT_BUFFER: DescriptorType = .{ .bits = @as(c_uint, @intCast((DescriptorType.DESCRIPTOR_TYPE_INDEX_BUFFER.bits << 1))) };
    /// Cubemap SRV
    pub const DESCRIPTOR_TYPE_TEXTURE_CUBE: DescriptorType = .{ .bits = @as(c_uint, @intCast((DescriptorType.DESCRIPTOR_TYPE_TEXTURE.bits | (DescriptorType.DESCRIPTOR_TYPE_INDIRECT_BUFFER.bits << 1)))) };
    /// RTV / DSV per mip slice
    pub const DESCRIPTOR_TYPE_RENDER_TARGET_MIP_SLICES: DescriptorType = .{ .bits = @as(c_uint, @intCast((DescriptorType.DESCRIPTOR_TYPE_INDIRECT_BUFFER.bits << 2))) };
    /// RTV / DSV per array slice
    pub const DESCRIPTOR_TYPE_RENDER_TARGET_ARRAY_SLICES: DescriptorType = .{ .bits = @as(c_uint, @intCast((DescriptorType.DESCRIPTOR_TYPE_RENDER_TARGET_MIP_SLICES.bits << 1))) };
    /// RTV / DSV per depth slice
    pub const DESCRIPTOR_TYPE_RENDER_TARGET_DEPTH_SLICES: DescriptorType = .{ .bits = @as(c_uint, @intCast((DescriptorType.DESCRIPTOR_TYPE_RENDER_TARGET_ARRAY_SLICES.bits << 1))) };
    /// RTV / DSV per depth slice
    pub const DESCRIPTOR_TYPE_INDIRECT_COMMAND_BUFFER: DescriptorType = .{ .bits = @as(c_uint, @intCast((DescriptorType.DESCRIPTOR_TYPE_RENDER_TARGET_DEPTH_SLICES.bits << 1))) };
    /// Raytracing acceleration structure
    pub const DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE: DescriptorType = .{ .bits = @as(c_uint, @intCast((DescriptorType.DESCRIPTOR_TYPE_INDIRECT_COMMAND_BUFFER.bits << 1))) };

    // pub usingnamespace cpp.FlagsMixin(DescriptorType);
};

///*********************************************
pub const SampleCount = extern struct {
    bits: c_int = 0,

    pub const SAMPLE_COUNT_1: SampleCount = .{ .bits = @as(c_uint, @intCast(1)) };
    pub const SAMPLE_COUNT_2: SampleCount = .{ .bits = @as(c_uint, @intCast(2)) };
    pub const SAMPLE_COUNT_4: SampleCount = .{ .bits = @as(c_uint, @intCast(4)) };
    pub const SAMPLE_COUNT_8: SampleCount = .{ .bits = @as(c_uint, @intCast(8)) };
    pub const SAMPLE_COUNT_16: SampleCount = .{ .bits = @as(c_uint, @intCast(16)) };
    pub const SAMPLE_COUNT_COUNT: SampleCount = .{ .bits = @as(c_uint, @intCast(5)) };

    // pub usingnamespace cpp.FlagsMixin(SampleCount);
};

pub const ShaderStage = extern struct {
    bits: c_int = 0,

    pub const SHADER_STAGE_NONE: ShaderStage = .{ .bits = @as(c_uint, @intCast(0)) };
    pub const SHADER_STAGE_VERT: ShaderStage = .{ .bits = @as(c_uint, @intCast(1)) };
    pub const SHADER_STAGE_TESC: ShaderStage = .{ .bits = @as(c_uint, @intCast(2)) };
    pub const SHADER_STAGE_TESE: ShaderStage = .{ .bits = @as(c_uint, @intCast(4)) };
    pub const SHADER_STAGE_GEOM: ShaderStage = .{ .bits = @as(c_uint, @intCast(8)) };
    pub const SHADER_STAGE_FRAG: ShaderStage = .{ .bits = @as(c_uint, @intCast(16)) };
    pub const SHADER_STAGE_COMP: ShaderStage = .{ .bits = @as(c_uint, @intCast(32)) };
    pub const SHADER_STAGE_ALL_GRAPHICS: ShaderStage = .{ .bits = (@as(u32, @intCast(ShaderStage.SHADER_STAGE_VERT.bits)) | @as(u32, @intCast(ShaderStage.SHADER_STAGE_TESC.bits)) | @as(u32, @intCast(ShaderStage.SHADER_STAGE_TESE.bits)) | @as(u32, @intCast(ShaderStage.SHADER_STAGE_GEOM.bits)) | @as(u32, @intCast(ShaderStage.SHADER_STAGE_FRAG.bits))) };
    pub const SHADER_STAGE_HULL: ShaderStage = .{ .bits = @as(c_uint, @intCast(ShaderStage.SHADER_STAGE_TESC.bits)) };
    pub const SHADER_STAGE_DOMN: ShaderStage = .{ .bits = @as(c_uint, @intCast(ShaderStage.SHADER_STAGE_TESE.bits)) };
    pub const SHADER_STAGE_COUNT: ShaderStage = .{ .bits = @as(c_uint, @intCast(6)) };

    // pub usingnamespace cpp.FlagsMixin(ShaderStage);
};

pub const ShaderStageIndex = extern struct {
    bits: c_int = 0,

    pub const SHADER_STAGE_INDEX_VERT: ShaderStageIndex = .{ .bits = @as(c_uint, @intCast(0)) };
    pub const SHADER_STAGE_INDEX_TESC: ShaderStageIndex = .{ .bits = ShaderStageIndex.SHADER_STAGE_INDEX_VERT.bits + 1 };
    pub const SHADER_STAGE_INDEX_TESE: ShaderStageIndex = .{ .bits = ShaderStageIndex.SHADER_STAGE_INDEX_VERT.bits + 2 };
    pub const SHADER_STAGE_INDEX_GEOM: ShaderStageIndex = .{ .bits = ShaderStageIndex.SHADER_STAGE_INDEX_VERT.bits + 3 };
    pub const SHADER_STAGE_INDEX_FRAG: ShaderStageIndex = .{ .bits = ShaderStageIndex.SHADER_STAGE_INDEX_VERT.bits + 4 };
    pub const SHADER_STAGE_INDEX_COMP: ShaderStageIndex = .{ .bits = ShaderStageIndex.SHADER_STAGE_INDEX_VERT.bits + 5 };
    pub const SHADER_STAGE_INDEX_HULL: ShaderStageIndex = .{ .bits = @as(c_uint, @intCast(ShaderStageIndex.SHADER_STAGE_INDEX_TESC.bits)) };
    pub const SHADER_STAGE_INDEX_DOMN: ShaderStageIndex = .{ .bits = @as(c_uint, @intCast(ShaderStageIndex.SHADER_STAGE_INDEX_TESE.bits)) };

    // pub usingnamespace cpp.FlagsMixin(ShaderStageIndex);
};

pub const PrimitiveTopology = extern struct {
    bits: c_int = 0,

    pub const PRIMITIVE_TOPO_POINT_LIST: PrimitiveTopology = .{ .bits = @as(c_uint, @intCast(0)) };
    pub const PRIMITIVE_TOPO_LINE_LIST: PrimitiveTopology = .{ .bits = PrimitiveTopology.PRIMITIVE_TOPO_POINT_LIST.bits + 1 };
    pub const PRIMITIVE_TOPO_LINE_STRIP: PrimitiveTopology = .{ .bits = PrimitiveTopology.PRIMITIVE_TOPO_POINT_LIST.bits + 2 };
    pub const PRIMITIVE_TOPO_TRI_LIST: PrimitiveTopology = .{ .bits = PrimitiveTopology.PRIMITIVE_TOPO_POINT_LIST.bits + 3 };
    pub const PRIMITIVE_TOPO_TRI_STRIP: PrimitiveTopology = .{ .bits = PrimitiveTopology.PRIMITIVE_TOPO_POINT_LIST.bits + 4 };
    pub const PRIMITIVE_TOPO_PATCH_LIST: PrimitiveTopology = .{ .bits = PrimitiveTopology.PRIMITIVE_TOPO_POINT_LIST.bits + 5 };
    pub const PRIMITIVE_TOPO_COUNT: PrimitiveTopology = .{ .bits = PrimitiveTopology.PRIMITIVE_TOPO_POINT_LIST.bits + 6 };

    // pub usingnamespace cpp.FlagsMixin(PrimitiveTopology);
};

pub const IndexType = extern struct {
    bits: c_int = 0,

    pub const INDEX_TYPE_UINT32: IndexType = .{ .bits = @as(c_uint, @intCast(0)) };
    pub const INDEX_TYPE_UINT16: IndexType = .{ .bits = IndexType.INDEX_TYPE_UINT32.bits + 1 };

    // pub usingnamespace cpp.FlagsMixin(IndexType);
};

pub const ShaderSemantic = enum(u32) {
    UNDEFINED,
    POSITION,
    NORMAL,
    COLOR,
    TANGENT,
    BITANGENT,
    JOINTS,
    WEIGHTS,
    CUSTOM,
    TEXCOORD0,
    TEXCOORD1,
    TEXCOORD2,
    TEXCOORD3,
    TEXCOORD4,
    TEXCOORD5,
    TEXCOORD6,
    TEXCOORD7,
    TEXCOORD8,
    TEXCOORD9,
    MAX_SEMANTICS,
};

pub const BlendConstant = extern struct {
    bits: c_int = 0,

    pub const BC_ZERO: BlendConstant = .{ .bits = @as(c_uint, @intCast(0)) };
    pub const BC_ONE: BlendConstant = .{ .bits = BlendConstant.BC_ZERO.bits + 1 };
    pub const BC_SRC_COLOR: BlendConstant = .{ .bits = BlendConstant.BC_ZERO.bits + 2 };
    pub const BC_ONE_MINUS_SRC_COLOR: BlendConstant = .{ .bits = BlendConstant.BC_ZERO.bits + 3 };
    pub const BC_DST_COLOR: BlendConstant = .{ .bits = BlendConstant.BC_ZERO.bits + 4 };
    pub const BC_ONE_MINUS_DST_COLOR: BlendConstant = .{ .bits = BlendConstant.BC_ZERO.bits + 5 };
    pub const BC_SRC_ALPHA: BlendConstant = .{ .bits = BlendConstant.BC_ZERO.bits + 6 };
    pub const BC_ONE_MINUS_SRC_ALPHA: BlendConstant = .{ .bits = BlendConstant.BC_ZERO.bits + 7 };
    pub const BC_DST_ALPHA: BlendConstant = .{ .bits = BlendConstant.BC_ZERO.bits + 8 };
    pub const BC_ONE_MINUS_DST_ALPHA: BlendConstant = .{ .bits = BlendConstant.BC_ZERO.bits + 9 };
    pub const BC_SRC_ALPHA_SATURATE: BlendConstant = .{ .bits = BlendConstant.BC_ZERO.bits + 10 };
    pub const BC_BLEND_FACTOR: BlendConstant = .{ .bits = BlendConstant.BC_ZERO.bits + 11 };
    pub const BC_ONE_MINUS_BLEND_FACTOR: BlendConstant = .{ .bits = BlendConstant.BC_ZERO.bits + 12 };
    pub const MAX_BLEND_CONSTANTS: BlendConstant = .{ .bits = BlendConstant.BC_ZERO.bits + 13 };

    // pub usingnamespace cpp.FlagsMixin(BlendConstant);
};

pub const BlendMode = extern struct {
    bits: c_int = 0,

    pub const BM_ADD: BlendMode = .{ .bits = 0 };
    pub const BM_SUBTRACT: BlendMode = .{ .bits = 1 };
    pub const BM_REVERSE_SUBTRACT: BlendMode = .{ .bits = 2 };
    pub const BM_MIN: BlendMode = .{ .bits = 3 };
    pub const BM_MAX: BlendMode = .{ .bits = 4 };
    pub const MAX_BLEND_MODES: BlendMode = .{ .bits = 5 };

    // pub usingnamespace cpp.FlagsMixin(BlendMode);
};

pub const CompareMode = extern struct {
    bits: c_int = 0,

    pub const CMP_NEVER: CompareMode = .{ .bits = 0 };
    pub const CMP_LESS: CompareMode = .{ .bits = 1 };
    pub const CMP_EQUAL: CompareMode = .{ .bits = 2 };
    pub const CMP_LEQUAL: CompareMode = .{ .bits = 3 };
    pub const CMP_GREATER: CompareMode = .{ .bits = 4 };
    pub const CMP_NOTEQUAL: CompareMode = .{ .bits = 5 };
    pub const CMP_GEQUAL: CompareMode = .{ .bits = 6 };
    pub const CMP_ALWAYS: CompareMode = .{ .bits = 7 };
    pub const MAX_COMPARE_MODES: CompareMode = .{ .bits = 8 };

    // pub usingnamespace cpp.FlagsMixin(CompareMode);
};

pub const StencilOp = extern struct {
    bits: c_int = 0,

    pub const STENCIL_OP_KEEP: StencilOp = .{ .bits = 0 };
    pub const STENCIL_OP_SET_ZERO: StencilOp = .{ .bits = 1 };
    pub const STENCIL_OP_REPLACE: StencilOp = .{ .bits = 2 };
    pub const STENCIL_OP_INVERT: StencilOp = .{ .bits = 3 };
    pub const STENCIL_OP_INCR: StencilOp = .{ .bits = 4 };
    pub const STENCIL_OP_DECR: StencilOp = .{ .bits = 5 };
    pub const STENCIL_OP_INCR_SAT: StencilOp = .{ .bits = 6 };
    pub const STENCIL_OP_DECR_SAT: StencilOp = .{ .bits = 7 };
    pub const MAX_STENCIL_OPS: StencilOp = .{ .bits = 8 };

    // pub usingnamespace cpp.FlagsMixin(StencilOp);
};

pub const ColorMask = extern struct {
    bits: c_int = 0,

    pub const COLOR_MASK_NONE: ColorMask = .{ .bits = @as(c_uint, @intCast(0)) };
    pub const COLOR_MASK_RED: ColorMask = .{ .bits = @as(c_uint, @intCast(1)) };
    pub const COLOR_MASK_GREEN: ColorMask = .{ .bits = @as(c_uint, @intCast(2)) };
    pub const COLOR_MASK_BLUE: ColorMask = .{ .bits = @as(c_uint, @intCast(4)) };
    pub const COLOR_MASK_ALPHA: ColorMask = .{ .bits = @as(c_uint, @intCast(8)) };
    pub const COLOR_MASK_ALL: ColorMask = .{ .bits = @as(c_uint, @intCast((ColorMask.COLOR_MASK_RED.bits | ColorMask.COLOR_MASK_GREEN.bits | ColorMask.COLOR_MASK_BLUE.bits | ColorMask.COLOR_MASK_ALPHA.bits))) };

    // pub usingnamespace cpp.FlagsMixin(ColorMask);
};

/// Blend states are always attached to one of the eight or more render targets that
/// are in a MRT
/// Mask constants
pub const BlendStateTargets = extern struct {
    bits: c_int = 0,

    pub const BLEND_STATE_TARGET_0: BlendStateTargets = .{ .bits = @as(c_uint, @intCast(1)) };
    pub const BLEND_STATE_TARGET_1: BlendStateTargets = .{ .bits = @as(c_uint, @intCast(2)) };
    pub const BLEND_STATE_TARGET_2: BlendStateTargets = .{ .bits = @as(c_uint, @intCast(4)) };
    pub const BLEND_STATE_TARGET_3: BlendStateTargets = .{ .bits = @as(c_uint, @intCast(8)) };
    pub const BLEND_STATE_TARGET_4: BlendStateTargets = .{ .bits = @as(c_uint, @intCast(16)) };
    pub const BLEND_STATE_TARGET_5: BlendStateTargets = .{ .bits = @as(c_uint, @intCast(32)) };
    pub const BLEND_STATE_TARGET_6: BlendStateTargets = .{ .bits = @as(c_uint, @intCast(64)) };
    pub const BLEND_STATE_TARGET_7: BlendStateTargets = .{ .bits = @as(c_uint, @intCast(128)) };
    pub const BLEND_STATE_TARGET_ALL: BlendStateTargets = .{ .bits = @as(c_uint, @intCast(255)) };

    // pub usingnamespace cpp.FlagsMixin(BlendStateTargets);
};

/// Blend states are always attached to one of the eight or more render targets that
/// are in a MRT
/// Mask constants
pub const CullMode = extern struct {
    bits: c_int = 0,

    pub const CULL_MODE_NONE: CullMode = .{ .bits = @as(c_uint, @intCast(0)) };
    pub const CULL_MODE_BACK: CullMode = .{ .bits = CullMode.CULL_MODE_NONE.bits + 1 };
    pub const CULL_MODE_FRONT: CullMode = .{ .bits = CullMode.CULL_MODE_NONE.bits + 2 };
    pub const CULL_MODE_BOTH: CullMode = .{ .bits = CullMode.CULL_MODE_NONE.bits + 3 };
    pub const MAX_CULL_MODES: CullMode = .{ .bits = CullMode.CULL_MODE_NONE.bits + 4 };

    // pub usingnamespace cpp.FlagsMixin(CullMode);
};

pub const FrontFace = extern struct {
    bits: c_int = 0,

    pub const FRONT_FACE_CCW: FrontFace = .{ .bits = @as(c_uint, @intCast(0)) };
    pub const FRONT_FACE_CW: FrontFace = .{ .bits = FrontFace.FRONT_FACE_CCW.bits + 1 };

    // pub usingnamespace cpp.FlagsMixin(FrontFace);
};

pub const FillMode = extern struct {
    bits: c_int = 0,

    pub const FILL_MODE_SOLID: FillMode = .{ .bits = 0 };
    pub const FILL_MODE_WIREFRAME: FillMode = .{ .bits = 1 };
    pub const MAX_FILL_MODES: FillMode = .{ .bits = 2 };

    // pub usingnamespace cpp.FlagsMixin(FillMode);
};

pub const PipelineType = extern struct {
    bits: c_int = 0,

    pub const PIPELINE_TYPE_UNDEFINED: PipelineType = .{ .bits = @as(c_uint, @intCast(0)) };
    pub const PIPELINE_TYPE_COMPUTE: PipelineType = .{ .bits = PipelineType.PIPELINE_TYPE_UNDEFINED.bits + 1 };
    pub const PIPELINE_TYPE_GRAPHICS: PipelineType = .{ .bits = PipelineType.PIPELINE_TYPE_UNDEFINED.bits + 2 };
    pub const PIPELINE_TYPE_COUNT: PipelineType = .{ .bits = PipelineType.PIPELINE_TYPE_UNDEFINED.bits + 3 };

    // pub usingnamespace cpp.FlagsMixin(PipelineType);
};

pub const FilterType = extern struct {
    bits: c_int = 0,

    pub const FILTER_NEAREST: FilterType = .{ .bits = @as(c_uint, @intCast(0)) };
    pub const FILTER_LINEAR: FilterType = .{ .bits = FilterType.FILTER_NEAREST.bits + 1 };

    // pub usingnamespace cpp.FlagsMixin(FilterType);
};

pub const AddressMode = extern struct {
    bits: c_int = 0,

    pub const ADDRESS_MODE_MIRROR: AddressMode = .{ .bits = 0 };
    pub const ADDRESS_MODE_REPEAT: AddressMode = .{ .bits = 1 };
    pub const ADDRESS_MODE_CLAMP_TO_EDGE: AddressMode = .{ .bits = 2 };
    pub const ADDRESS_MODE_CLAMP_TO_BORDER: AddressMode = .{ .bits = 3 };

    // pub usingnamespace cpp.FlagsMixin(AddressMode);
};

pub const MipMapMode = extern struct {
    bits: c_int = 0,

    pub const MIPMAP_MODE_NEAREST: MipMapMode = .{ .bits = @as(c_uint, @intCast(0)) };
    pub const MIPMAP_MODE_LINEAR: MipMapMode = .{ .bits = MipMapMode.MIPMAP_MODE_NEAREST.bits + 1 };

    // pub usingnamespace cpp.FlagsMixin(MipMapMode);
};

pub const ClearValue = extern union {
    __struct_field1: __Struct0,
    __struct_field3: __Struct2,

    pub const __Struct0 = extern struct {
        r: f32,
        g: f32,
        b: f32,
        a: f32,
    };

    pub const __Struct2 = extern struct {
        depth: f32,
        stencil: u32,
    };
};

pub const BufferCreationFlags = extern struct {
    bits: c_int = 0,

    /// Default flag (Buffer will use aliased memory, buffer will not be cpu accessible until mapBuffer is called)
    pub const BUFFER_CREATION_FLAG_NONE: BufferCreationFlags = .{ .bits = @as(c_uint, @intCast(0)) };
    /// Buffer will allocate its own memory (COMMITTED resource)
    pub const BUFFER_CREATION_FLAG_OWN_MEMORY_BIT: BufferCreationFlags = .{ .bits = @as(c_uint, @intCast(1)) };
    /// Buffer will be persistently mapped
    pub const BUFFER_CREATION_FLAG_PERSISTENT_MAP_BIT: BufferCreationFlags = .{ .bits = @as(c_uint, @intCast(2)) };
    /// Use ESRAM to store this buffer
    pub const BUFFER_CREATION_FLAG_ESRAM: BufferCreationFlags = .{ .bits = @as(c_uint, @intCast(4)) };
    /// Flag to specify not to allocate descriptors for the resource
    pub const BUFFER_CREATION_FLAG_NO_DESCRIPTOR_VIEW_CREATION: BufferCreationFlags = .{ .bits = @as(c_uint, @intCast(8)) };
    /// Flag to specify not to allocate descriptors for the resource
    pub const BUFFER_CREATION_FLAG_ACCELERATION_STRUCTURE_BUILD_INPUT: BufferCreationFlags = .{ .bits = @as(c_uint, @intCast(16)) };
    /// Flag to specify not to allocate descriptors for the resource
    pub const BUFFER_CREATION_FLAG_SHADER_DEVICE_ADDRESS: BufferCreationFlags = .{ .bits = @as(c_uint, @intCast(32)) };
    /// Flag to specify not to allocate descriptors for the resource
    pub const BUFFER_CREATION_FLAG_SHADER_BINDING_TABLE: BufferCreationFlags = .{ .bits = @as(c_uint, @intCast(64)) };

    // pub usingnamespace cpp.FlagsMixin(BufferCreationFlags);
};

pub const TextureCreationFlags = extern struct {
    bits: c_int = 0,

    /// Default flag (Texture will use default allocation strategy decided by the api specific allocator)
    pub const TEXTURE_CREATION_FLAG_NONE: TextureCreationFlags = .{ .bits = @as(c_uint, @intCast(0)) };
    /// Texture will allocate its own memory (COMMITTED resource)
    pub const TEXTURE_CREATION_FLAG_OWN_MEMORY_BIT: TextureCreationFlags = .{ .bits = @as(c_uint, @intCast(1)) };
    /// Texture will be allocated in memory which can be shared among multiple processes
    pub const TEXTURE_CREATION_FLAG_EXPORT_BIT: TextureCreationFlags = .{ .bits = @as(c_uint, @intCast(2)) };
    /// Texture will be allocated in memory which can be shared among multiple gpus
    pub const TEXTURE_CREATION_FLAG_EXPORT_ADAPTER_BIT: TextureCreationFlags = .{ .bits = @as(c_uint, @intCast(4)) };
    /// Texture will be imported from a handle created in another process
    pub const TEXTURE_CREATION_FLAG_IMPORT_BIT: TextureCreationFlags = .{ .bits = @as(c_uint, @intCast(8)) };
    /// Use ESRAM to store this texture
    pub const TEXTURE_CREATION_FLAG_ESRAM: TextureCreationFlags = .{ .bits = @as(c_uint, @intCast(16)) };
    /// Use on-tile memory to store this texture
    pub const TEXTURE_CREATION_FLAG_ON_TILE: TextureCreationFlags = .{ .bits = @as(c_uint, @intCast(32)) };
    /// Prevent compression meta data from generating (XBox)
    pub const TEXTURE_CREATION_FLAG_NO_COMPRESSION: TextureCreationFlags = .{ .bits = @as(c_uint, @intCast(64)) };
    /// Force 2D instead of automatically determining dimension based on width, height, depth
    pub const TEXTURE_CREATION_FLAG_FORCE_2D: TextureCreationFlags = .{ .bits = @as(c_uint, @intCast(128)) };
    /// Force 3D instead of automatically determining dimension based on width, height, depth
    pub const TEXTURE_CREATION_FLAG_FORCE_3D: TextureCreationFlags = .{ .bits = @as(c_uint, @intCast(256)) };
    /// Display target
    pub const TEXTURE_CREATION_FLAG_ALLOW_DISPLAY_TARGET: TextureCreationFlags = .{ .bits = @as(c_uint, @intCast(512)) };
    /// Create an sRGB texture.
    pub const TEXTURE_CREATION_FLAG_SRGB: TextureCreationFlags = .{ .bits = @as(c_uint, @intCast(1024)) };
    /// Create a normal map texture
    pub const TEXTURE_CREATION_FLAG_NORMAL_MAP: TextureCreationFlags = .{ .bits = @as(c_uint, @intCast(2048)) };
    /// Fast clear
    pub const TEXTURE_CREATION_FLAG_FAST_CLEAR: TextureCreationFlags = .{ .bits = @as(c_uint, @intCast(4096)) };
    /// Fragment mask
    pub const TEXTURE_CREATION_FLAG_FRAG_MASK: TextureCreationFlags = .{ .bits = @as(c_uint, @intCast(8192)) };
    /// Doubles the amount of array layers of the texture when rendering VR. Also forces the texture to be a 2D Array texture.
    pub const TEXTURE_CREATION_FLAG_VR_MULTIVIEW: TextureCreationFlags = .{ .bits = @as(c_uint, @intCast(16384)) };
    /// Binds the FFR fragment density if this texture is used as a render target.
    pub const TEXTURE_CREATION_FLAG_VR_FOVEATED_RENDERING: TextureCreationFlags = .{ .bits = @as(c_uint, @intCast(32768)) };

    // pub usingnamespace cpp.FlagsMixin(TextureCreationFlags);
};

/// Used for swapchain
pub const ColorSpace = extern struct {
    bits: c_int = 0,

    pub const COLOR_SPACE_SDR_LINEAR: ColorSpace = .{ .bits = @as(c_uint, @intCast(0)) };
    pub const COLOR_SPACE_SDR_SRGB: ColorSpace = .{ .bits = ColorSpace.COLOR_SPACE_SDR_LINEAR.bits + 1 };
    /// BT2020 color space with PQ EOTF
    pub const COLOR_SPACE_P2020: ColorSpace = .{ .bits = ColorSpace.COLOR_SPACE_SDR_LINEAR.bits + 2 };
    /// Extended sRGB with linear EOTF
    pub const COLOR_SPACE_EXTENDED_SRGB: ColorSpace = .{ .bits = ColorSpace.COLOR_SPACE_SDR_LINEAR.bits + 3 };

    // pub usingnamespace cpp.FlagsMixin(ColorSpace);
};

/// Used for swapchain
pub const GPUPresetLevel = extern struct {
    bits: c_int = 0,

    pub const GPU_PRESET_NONE: GPUPresetLevel = .{ .bits = @as(c_uint, @intCast(0)) };
    /// This means unsupported
    pub const GPU_PRESET_OFFICE: GPUPresetLevel = .{ .bits = GPUPresetLevel.GPU_PRESET_NONE.bits + 1 };
    /// Mostly for mobile GPU
    pub const GPU_PRESET_VERYLOW: GPUPresetLevel = .{ .bits = GPUPresetLevel.GPU_PRESET_NONE.bits + 2 };
    pub const GPU_PRESET_LOW: GPUPresetLevel = .{ .bits = GPUPresetLevel.GPU_PRESET_NONE.bits + 3 };
    pub const GPU_PRESET_MEDIUM: GPUPresetLevel = .{ .bits = GPUPresetLevel.GPU_PRESET_NONE.bits + 4 };
    pub const GPU_PRESET_HIGH: GPUPresetLevel = .{ .bits = GPUPresetLevel.GPU_PRESET_NONE.bits + 5 };
    pub const GPU_PRESET_ULTRA: GPUPresetLevel = .{ .bits = GPUPresetLevel.GPU_PRESET_NONE.bits + 6 };
    pub const GPU_PRESET_COUNT: GPUPresetLevel = .{ .bits = GPUPresetLevel.GPU_PRESET_NONE.bits + 7 };

    // pub usingnamespace cpp.FlagsMixin(GPUPresetLevel);
};

pub const BufferBarrier = extern struct {
    pBuffer: [*c]Buffer,
    mCurrentState: ResourceState,
    mNewState: ResourceState,
    bitfield_1: packed struct(u8) {
        mBeginOnly: u1, // 1 bits
        mEndOnly: u1, // 2 bits
        /// Padding added by c2z
        _dummy_padding: u6,
    },
};

pub const TextureBarrier = extern struct {
    pTexture: [*c]Texture,
    mCurrentState: ResourceState,
    mNewState: ResourceState,
    bitfield_1: packed struct(u8) {
        mBeginOnly: u1, // 1 bits
        mEndOnly: u1, // 2 bits
        mAcquire: u1, // 3 bits
        mRelease: u1, // 4 bits
        /// Padding added by c2z
        _dummy_padding: u4,
    },

    bitfield_2: packed struct(u8) {
        mQueueType: u5, // 5 bits
        /// Specifiy whether following barrier targets particular subresource
        mSubresourceBarrier: u1, // 6 bits
        /// Padding added by c2z
        _dummy_padding: u2,
    },

    bitfield_3: packed struct(u8) {
        /// Following values are ignored if mSubresourceBarrier is false
        mMipLevel: u7, // 7 bits
        /// Padding added by c2z
        _dummy_padding: u1,
    },

    mArrayLayer: u16,

    pub fn init(texture: [*c]Texture, current_state: ResourceState, new_state: ResourceState) TextureBarrier {
        var barrier = std.mem.zeroes(TextureBarrier);
        barrier.pTexture = texture;
        barrier.mCurrentState = current_state;
        barrier.mNewState = new_state;

        return barrier;
    }
};

pub const RenderTargetBarrier = extern struct {
    pRenderTarget: [*c]RenderTarget,
    mCurrentState: ResourceState,
    mNewState: ResourceState,
    bitfield_1: packed struct(u8) {
        mBeginOnly: u1, // 1 bits
        mEndOnly: u1, // 2 bits
        mAcquire: u1, // 3 bits
        mRelease: u1, // 4 bits
        /// Padding added by c2z
        _dummy_padding: u4,
    },

    bitfield_2: packed struct(u8) {
        mQueueType: u5, // 5 bits
        /// Specifiy whether following barrier targets particular subresource
        mSubresourceBarrier: u1, // 6 bits
        /// Padding added by c2z
        _dummy_padding: u2,
    },

    bitfield_3: packed struct(u8) {
        /// Following values are ignored if mSubresourceBarrier is false
        mMipLevel: u7, // 7 bits
        /// Padding added by c2z
        _dummy_padding: u1,
    },

    mArrayLayer: u16,

    pub fn init(render_target: [*c]RenderTarget, current_state: ResourceState, new_state: ResourceState) RenderTargetBarrier {
        var barrier = std.mem.zeroes(RenderTargetBarrier);
        barrier.pRenderTarget = render_target;
        barrier.mCurrentState = current_state;
        barrier.mNewState = new_state;

        return barrier;
    }
};

pub const ReadRange = extern struct {
    mOffset: u64,
    mSize: u64,
};

pub const QueryType = extern struct {
    bits: c_int = 0,

    pub const QUERY_TYPE_TIMESTAMP: QueryType = .{ .bits = @as(c_uint, @intCast(0)) };
    pub const QUERY_TYPE_OCCLUSION: QueryType = .{ .bits = QueryType.QUERY_TYPE_TIMESTAMP.bits + 1 };
    pub const QUERY_TYPE_PIPELINE_STATISTICS: QueryType = .{ .bits = QueryType.QUERY_TYPE_TIMESTAMP.bits + 2 };
    pub const QUERY_TYPE_COUNT: QueryType = .{ .bits = QueryType.QUERY_TYPE_TIMESTAMP.bits + 3 };

    // pub usingnamespace cpp.FlagsMixin(QueryType);
};

pub const QueryPoolDesc = extern struct {
    pName: [*c]const u8,
    mType: QueryType,
    mQueryCount: u32,
    mNodeIndex: u32,
};

pub const QueryDesc = extern struct {
    mIndex: u32,
};

pub const QueryPool = extern struct {
    mDx: __Struct0,
    mCount: u32,
    mStride: u32,

    pub const __Struct0 = extern struct {
        pQueryHeap: *ID3D12QueryHeap,
        pReadbackBuffer: [*c]Buffer,
        mType: D3D12_QUERY_TYPE,
    };
};

pub const PipelineStatisticsQueryData = extern struct {
    mIAVertices: u64,
    mIAPrimitives: u64,
    mVSInvocations: u64,
    mGSInvocations: u64,
    mGSPrimitives: u64,
    mCInvocations: u64,
    mCPrimitives: u64,
    mPSInvocations: u64,
    mHSInvocations: u64,
    mDSInvocations: u64,
    mCSInvocations: u64,
};

pub const QueryData = extern struct {
    __union_field1: __Union0,
    mValid: bool,

    pub const __Union0 = extern union {
        __struct_field1: __Struct0,
        __struct_field3: __Struct2,
        mOcclusionCounts: u64,

        pub const __Struct0 = extern struct {
            mPipelineStats: PipelineStatisticsQueryData,
        };

        pub const __Struct2 = extern struct {
            mBeginTimestamp: u64,
            mEndTimestamp: u64,
        };
    };
};

pub const ResourceHeapCreationFlags = extern struct {
    bits: c_int = 0,

    pub const RESOURCE_HEAP_FLAG_NONE: ResourceHeapCreationFlags = .{ .bits = @as(c_uint, @intCast(0)) };
    pub const RESOURCE_HEAP_FLAG_SHARED: ResourceHeapCreationFlags = .{ .bits = @as(c_uint, @intCast(1)) };
    pub const RESOURCE_HEAP_FLAG_DENY_BUFFERS: ResourceHeapCreationFlags = .{ .bits = @as(c_uint, @intCast(2)) };
    pub const RESOURCE_HEAP_FLAG_ALLOW_DISPLAY: ResourceHeapCreationFlags = .{ .bits = @as(c_uint, @intCast(4)) };
    pub const RESOURCE_HEAP_FLAG_SHARED_CROSS_ADAPTER: ResourceHeapCreationFlags = .{ .bits = @as(c_uint, @intCast(8)) };
    pub const RESOURCE_HEAP_FLAG_DENY_RT_DS_TEXTURES: ResourceHeapCreationFlags = .{ .bits = @as(c_uint, @intCast(16)) };
    pub const RESOURCE_HEAP_FLAG_DENY_NON_RT_DS_TEXTURES: ResourceHeapCreationFlags = .{ .bits = @as(c_uint, @intCast(32)) };
    pub const RESOURCE_HEAP_FLAG_HARDWARE_PROTECTED: ResourceHeapCreationFlags = .{ .bits = @as(c_uint, @intCast(64)) };
    pub const RESOURCE_HEAP_FLAG_ALLOW_WRITE_WATCH: ResourceHeapCreationFlags = .{ .bits = @as(c_uint, @intCast(128)) };
    pub const RESOURCE_HEAP_FLAG_ALLOW_SHADER_ATOMICS: ResourceHeapCreationFlags = .{ .bits = @as(c_uint, @intCast(256)) };
    /// These are convenience aliases to manage resource heap tier restrictions. They cannot be bitwise OR'ed together cleanly.
    pub const RESOURCE_HEAP_FLAG_ALLOW_ALL_BUFFERS_AND_TEXTURES: ResourceHeapCreationFlags = .{ .bits = @as(c_uint, @intCast(512)) };
    /// These are convenience aliases to manage resource heap tier restrictions. They cannot be bitwise OR'ed together cleanly.
    pub const RESOURCE_HEAP_FLAG_ALLOW_ONLY_BUFFERS: ResourceHeapCreationFlags = .{ .bits = @as(c_uint, @intCast(ResourceHeapCreationFlags.RESOURCE_HEAP_FLAG_DENY_NON_RT_DS_TEXTURES.bits | ResourceHeapCreationFlags.RESOURCE_HEAP_FLAG_DENY_RT_DS_TEXTURES.bits)) };
    /// These are convenience aliases to manage resource heap tier restrictions. They cannot be bitwise OR'ed together cleanly.
    pub const RESOURCE_HEAP_FLAG_ALLOW_ONLY_NON_RT_DS_TEXTURES: ResourceHeapCreationFlags = .{ .bits = @as(c_uint, @intCast(ResourceHeapCreationFlags.RESOURCE_HEAP_FLAG_DENY_BUFFERS.bits | ResourceHeapCreationFlags.RESOURCE_HEAP_FLAG_DENY_RT_DS_TEXTURES.bits)) };
    /// These are convenience aliases to manage resource heap tier restrictions. They cannot be bitwise OR'ed together cleanly.
    pub const RESOURCE_HEAP_FLAG_ALLOW_ONLY_RT_DS_TEXTURES: ResourceHeapCreationFlags = .{ .bits = @as(c_uint, @intCast(ResourceHeapCreationFlags.RESOURCE_HEAP_FLAG_DENY_BUFFERS.bits | ResourceHeapCreationFlags.RESOURCE_HEAP_FLAG_DENY_NON_RT_DS_TEXTURES.bits)) };

    // pub usingnamespace cpp.FlagsMixin(ResourceHeapCreationFlags);
};

pub const ResourceHeapDesc = extern struct {
    mSize: u64,
    mAlignment: u64,
    mMemoryUsage: ResourceMemoryUsage,
    mDescriptors: DescriptorType,
    mFlags: ResourceHeapCreationFlags,
    mNodeIndex: u32,
    mSharedNodeIndexCount: u32,
    pSharedNodeIndices: [*c]u32,
    pName: [*c]const u8,
};

pub const ResourceHeap = extern struct {
    mDx: __Struct0,
    mSize: u64,

    pub const __Struct0 = extern struct {
        pHeap: *ID3D12Heap,
    };
};

pub const ResourceSizeAlign = extern struct {
    mSize: u64,
    mAlignment: u64,
};

pub const ResourcePlacement = extern struct {
    pHeap: [*c]ResourceHeap,
    mOffset: u64,
};

/// Data structure holding necessary info to create a Buffer
pub const BufferDesc = extern struct {
    /// Optional placement (addBuffer will place/bind buffer in this memory instead of allocating space)
    pPlacement: [*c]ResourcePlacement,
    /// Size of the buffer (in bytes)
    mSize: u64,
    /// Set this to specify a counter buffer for this buffer (applicable to BUFFER_USAGE_STORAGE_SRV, BUFFER_USAGE_STORAGE_UAV)
    pCounterBuffer: [*c]Buffer,
    /// Index of the first element accessible by the SRV/UAV (applicable to BUFFER_USAGE_STORAGE_SRV, BUFFER_USAGE_STORAGE_UAV)
    mFirstElement: u32,
    /// Number of elements in the buffer (applicable to BUFFER_USAGE_STORAGE_SRV, BUFFER_USAGE_STORAGE_UAV)
    mElementCount: u32,
    /// Size of each element (in bytes) in the buffer (applicable to BUFFER_USAGE_STORAGE_SRV, BUFFER_USAGE_STORAGE_UAV)
    mStructStride: u32,
    /// Alignment
    mAlignment: u32,
    /// Debug name used in gpu profile
    pName: [*c]const u8,
    pSharedNodeIndices: [*c]u32,
    /// Decides which memory heap buffer will use (default, upload, readback)
    mMemoryUsage: ResourceMemoryUsage,
    /// Creation flags of the buffer
    mFlags: BufferCreationFlags,
    /// What type of queue the buffer is owned by
    mQueueType: QueueType,
    /// What state will the buffer get created in
    mStartState: ResourceState,
    /// ICB draw type
    mICBDrawType: IndirectArgumentType,
    /// ICB max commands in indirect command buffer
    mICBMaxCommandCount: u32,
    /// Format of the buffer (applicable to typed storage buffers (Buffer
    ///<T
    ///>)
    mFormat: TinyImageFormat,
    /// Flags specifying the suitable usage of this buffer (Uniform buffer, Vertex Buffer, Index Buffer,...)
    mDescriptors: DescriptorType,
    /// The index of the GPU in SLI/Cross-Fire that owns this buffer, or the Renderer index in unlinked mode.
    mNodeIndex: u32,
    mSharedNodeIndexCount: u32,
    bBindless: bool,
};

/// Data structure holding necessary info to create a Buffer
pub const Buffer = extern struct {
    /// CPU address of the mapped buffer (applicable to buffers created in CPU accessible heaps (CPU, CPU_TO_GPU, GPU_TO_CPU)
    pCpuMappedAddress: ?*anyopaque,
    mDx: __Struct0,
    bitfield_1: packed struct(u64) {
        mSize: u32, // 32 bits
        mDescriptors: u20, // 52 bits
        mMemoryUsage: u3, // 55 bits
        mNodeIndex: u4, // 59 bits
        /// Padding added by c2z
        _dummy_padding: u5,
    },

    pub const __Struct0 = extern struct {
        /// GPU Address - Cache to avoid calls to ID3D12Resource::GetGpuVirtualAddress
        mGpuAddress: D3D12_GPU_VIRTUAL_ADDRESS,
        /// Descriptor handle of the CBV in a CPU visible descriptor heap (applicable to BUFFER_USAGE_UNIFORM)
        mDescriptors: DxDescriptorID,
        /// Offset from mDescriptors for srv descriptor handle
        mSrvDescriptorOffset: u8,
        /// Offset from mDescriptors for uav descriptor handle
        mUavDescriptorOffset: u8,
        /// Native handle of the underlying resource
        pResource: *ID3D12Resource,
        /// Contains resource allocation info such as parent heap, offset in heap
        pAllocation: *D3D12MAAllocation,
    };
};

/// Data structure holding necessary info to create a Texture
pub const TextureDesc = extern struct {
    /// Optional placement (addTexture will place/bind buffer in this memory instead of allocating space)
    pPlacement: [*c]ResourcePlacement,
    /// Optimized clear value (recommended to use this same value when clearing the rendertarget)
    mClearValue: ClearValue,
    /// Pointer to native texture handle if the texture does not own underlying resource
    pNativeHandle: ?*const anyopaque,
    /// Debug name used in gpu profile
    pName: [*c]const u8,
    /// GPU indices to share this texture
    pSharedNodeIndices: [*c]u32,
    /// Texture creation flags (decides memory allocation strategy, sharing access,...)
    mFlags: TextureCreationFlags,
    /// Width
    mWidth: u32,
    /// Height
    mHeight: u32,
    /// Depth (Should be 1 if not a mType is not TEXTURE_TYPE_3D)
    mDepth: u32,
    /// Texture array size (Should be 1 if texture is not a texture array or cubemap)
    mArraySize: u32,
    /// Number of mip levels
    mMipLevels: u32,
    /// Number of multisamples per pixel (currently Textures created with mUsage TEXTURE_USAGE_SAMPLED_IMAGE only support SAMPLE_COUNT_1)
    mSampleCount: SampleCount,
    /// The image quality level. The higher the quality, the lower the performance. The valid range is between zero and the value
    /// appropriate for mSampleCount
    mSampleQuality: u32,
    ///  image format
    mFormat: TinyImageFormat,
    /// What state will the texture get created in
    mStartState: ResourceState,
    /// Descriptor creation
    mDescriptors: DescriptorType,
    /// Number of GPUs to share this texture
    mSharedNodeIndexCount: u32,
    /// GPU which will own this texture
    mNodeIndex: u32,
    bBindless: bool,
};

/// Data structure holding necessary info to create a Texture
pub const Texture = extern struct {
    mDx: __Struct0,
    bitfield_1: packed struct(u32) {
        /// Current state of the buffer
        mWidth: u16, // 16 bits
        mHeight: u16, // 32 bits
    },

    bitfield_2: packed struct(u32) {
        mDepth: u16, // 16 bits
        mMipLevels: u5, // 21 bits
        mArraySizeMinusOne: u11, // 32 bits
    },

    bitfield_3: packed struct(u32) {
        mFormat: u8, // 8 bits
        /// Flags specifying which aspects (COLOR,DEPTH,STENCIL) are included in the pImageView
        mAspectMask: u4, // 12 bits
        mNodeIndex: u4, // 16 bits
        mSampleCount: u5, // 21 bits
        mUav: u1, // 22 bits
        /// This value will be false if the underlying resource is not owned by the texture (swapchain textures,...)
        mOwnsImage: u1, // 23 bits
        /// Only applies to Vulkan but kept here as adding it inside mVk block increases the size of the struct and triggers assert below
        mLazilyAllocated: u1, // 24 bits
        /// Padding added by c2z
        _dummy_padding: u8,
    },

    pub const __Struct0 = extern struct {
        /// Descriptor handle of the SRV in a CPU visible descriptor heap (applicable to TEXTURE_USAGE_SAMPLED_IMAGE)
        mDescriptors: DxDescriptorID,
        /// Native handle of the underlying resource
        pResource: *ID3D12Resource,
        /// Contains resource allocation info such as parent heap, offset in heap
        pAllocation: *D3D12MAAllocation,

        bitfield_1: packed struct(u32) {
            mHandleCount: u24, // 24 bits
            /// Padding added by c2z
            _dummy_padding: u8,
        },

        mUavStartIndex: u32,
    };
};

pub const RenderTargetDesc = extern struct {
    /// Optional placement (addRenderTarget will place/bind buffer in this memory instead of allocating space)
    pPlacement: [*c]ResourcePlacement,
    /// Texture creation flags (decides memory allocation strategy, sharing access,...)
    mFlags: TextureCreationFlags,
    /// Width
    mWidth: u32,
    /// Height
    mHeight: u32,
    /// Depth (Should be 1 if not a mType is not TEXTURE_TYPE_3D)
    mDepth: u32,
    /// Texture array size (Should be 1 if texture is not a texture array or cubemap)
    mArraySize: u32,
    /// Number of mip levels
    mMipLevels: u32,
    /// MSAA
    mSampleCount: SampleCount,
    /// Internal image format
    mFormat: TinyImageFormat,
    /// What state will the texture get created in
    mStartState: ResourceState,
    /// Optimized clear value (recommended to use this same value when clearing the rendertarget)
    mClearValue: ClearValue,
    /// The image quality level. The higher the quality, the lower the performance. The valid range is between zero and the value
    /// appropriate for mSampleCount
    mSampleQuality: u32,
    /// Descriptor creation
    mDescriptors: DescriptorType,
    pNativeHandle: ?*const anyopaque,
    /// Debug name used in gpu profile
    pName: [*c]const u8,
    /// GPU indices to share this texture
    pSharedNodeIndices: [*c]u32,
    /// Number of GPUs to share this texture
    mSharedNodeIndexCount: u32,
    /// GPU which will own this texture
    mNodeIndex: u32,
};

pub const RenderTarget = extern struct {
    pTexture: [*c]Texture,
    mDx: __Struct0,
    mClearValue: ClearValue,
    bitfield_1: packed struct(u32) {
        mArraySize: u16, // 16 bits
        mDepth: u16, // 32 bits
    },

    bitfield_2: packed struct(u32) {
        mWidth: u16, // 16 bits
        mHeight: u16, // 32 bits
    },

    bitfield_3: packed struct(u32) {
        mDescriptors: u20, // 20 bits
        mMipLevels: u10, // 30 bits
        /// Padding added by c2z
        _dummy_padding: u2,
    },

    bitfield_4: packed struct(u32) {
        mSampleQuality: u5, // 5 bits
        /// Padding added by c2z
        _dummy_padding: u27,
    },

    mFormat: TinyImageFormat,
    mSampleCount: SampleCount,
    mVRMultiview: bool,
    mVRFoveatedRendering: bool,

    pub const __Struct0 = extern struct {
        mDescriptors: DxDescriptorID,
    };
};

pub const SampleLocations = extern struct {
    mX: i8,
    mY: i8,
};

pub const SamplerDesc = extern struct {
    mMinFilter: FilterType,
    mMagFilter: FilterType,
    mMipMapMode: MipMapMode,
    mAddressU: AddressMode,
    mAddressV: AddressMode,
    mAddressW: AddressMode,
    mMipLodBias: f32,
    mSetLodRange: bool,
    mMinLod: f32,
    mMaxLod: f32,
    mMaxAnisotropy: f32,
    mCompareFunc: CompareMode,
};

pub const Sampler = extern struct {
    mDx: __Struct0,

    pub const __Struct0 = extern struct {
        /// Description for creating the Sampler descriptor for this sampler
        mDesc: D3D12_SAMPLER_DESC,
        /// Descriptor handle of the Sampler in a CPU visible descriptor heap
        mDescriptor: DxDescriptorID,
    };
};

pub const DescriptorUpdateFrequency = extern struct {
    bits: c_int = 0,

    pub const DESCRIPTOR_UPDATE_FREQ_NONE: DescriptorUpdateFrequency = .{ .bits = @as(c_uint, @intCast(0)) };
    pub const DESCRIPTOR_UPDATE_FREQ_PER_FRAME: DescriptorUpdateFrequency = .{ .bits = DescriptorUpdateFrequency.DESCRIPTOR_UPDATE_FREQ_NONE.bits + 1 };
    pub const DESCRIPTOR_UPDATE_FREQ_PER_BATCH: DescriptorUpdateFrequency = .{ .bits = DescriptorUpdateFrequency.DESCRIPTOR_UPDATE_FREQ_NONE.bits + 2 };
    pub const DESCRIPTOR_UPDATE_FREQ_PER_DRAW: DescriptorUpdateFrequency = .{ .bits = DescriptorUpdateFrequency.DESCRIPTOR_UPDATE_FREQ_NONE.bits + 3 };
    pub const DESCRIPTOR_UPDATE_FREQ_COUNT: DescriptorUpdateFrequency = .{ .bits = DescriptorUpdateFrequency.DESCRIPTOR_UPDATE_FREQ_NONE.bits + 4 };

    // pub usingnamespace cpp.FlagsMixin(DescriptorUpdateFrequency);
};

/// Data structure holding the layout for a descriptor
pub const DescriptorInfo = extern struct {
    pName: [*c]const u8,
    mType: u32,
    bitfield_1: packed struct(u32) {
        mDim: u4, // 4 bits
        mRootDescriptor: u1, // 5 bits
        mStaticSampler: u1, // 6 bits
        mUpdateFrequency: u3, // 9 bits
        /// Padding added by c2z
        _dummy_padding: u23,
    },

    mSize: u32,
    mHandleIndex: u32,
    mDx: __Struct0,

    pub const __Struct0 = extern struct {
        mPadA: u64,
    };
};

/// Data structure holding the layout for a descriptor
pub const RootSignatureFlags = extern struct {
    bits: c_int = 0,

    /// Default flag
    pub const ROOT_SIGNATURE_FLAG_NONE: RootSignatureFlags = .{ .bits = @as(c_uint, @intCast(0)) };

    // pub usingnamespace cpp.FlagsMixin(RootSignatureFlags);
};

pub const RootSignatureDesc = extern struct {
    ppShaders: [*c][*c]Shader,
    mShaderCount: u32,
    mMaxBindlessTextures: u32,
    ppStaticSamplerNames: [*c]const [*c]u8,
    ppStaticSamplers: [*c][*c]Sampler,
    mStaticSamplerCount: u32,
    mFlags: RootSignatureFlags,
};

pub const RootSignature = extern struct {
    /// Number of descriptors declared in the root signature layout
    mDescriptorCount: u32,
    /// Graphics or Compute
    mPipelineType: PipelineType,
    /// Array of all descriptors declared in the root signature layout
    pDescriptors: [*c]DescriptorInfo,
    /// Translates hash of descriptor name to descriptor index in pDescriptors array
    pDescriptorNameToIndexMap: *DescriptorIndexMap,
    mDx: __Struct0,

    pub const __Struct0 = extern struct {
        pRootSignature: *ID3D12RootSignature,
        mViewDescriptorTableRootIndices: [4]u8,
        mSamplerDescriptorTableRootIndices: [4]u8,
        mCumulativeViewDescriptorCounts: [4]u32,
        mCumulativeSamplerDescriptorCounts: [4]u32,
        mViewDescriptorCounts: [4]u16,
        mSamplerDescriptorCounts: [4]u16,
        mHasRayQueryAccelerationStructure: bool,
    };
};

pub const DescriptorDataRange = extern struct {
    mOffset: u32,
    mSize: u32,
    /// Specify different structured buffer stride (ignored for raw buffer - ByteAddressBuffer)
    mStructStride: u32,
};

pub const DescriptorData = extern struct {
    /// User can either set name of descriptor or index (index in pRootSignature->pDescriptors array)
    /// Name of descriptor
    pName: [*c]const u8,
    bitfield_1: packed struct(u32) {
        /// Number of array entries to update (array size of ppTextures/ppBuffers/...)
        mCount: u31, // 31 bits
        /// Padding added by c2z
        _dummy_padding: u1,
    },

    bitfield_2: packed struct(u32) {
        /// Dst offset into the array descriptor (useful for updating few entries in a large array)
        /// Example: to update 6th entry in a bindless texture descriptor, mArrayOffset will be 6 and mCount will be 1)
        mArrayOffset: u20, // 20 bits
        /// Index in pRootSignature->pDescriptors array - Cache index using getDescriptorIndexFromName to avoid using string checks at runtime
        mIndex: u10, // 30 bits
        mBindByIndex: u1, // 31 bits
        /// Padding added by c2z
        _dummy_padding: u1,
    },

    /// Range to bind (buffer offset, size)
    pRanges: [*c]DescriptorDataRange,
    bitfield_3: packed struct(u8) {
        /// Binds stencil only descriptor instead of color/depth
        mBindStencilResource: u1, // 1 bits
        /// Padding added by c2z
        _dummy_padding: u7,
    },

    __union_field1: __Union0,
    __union_field3: __Union2,

    pub const __Union0 = extern union {
        __struct_field1: __Struct0,
        __struct_field3: __Struct2,

        pub const __Struct0 = extern struct {
            /// When binding UAV, control the mip slice to to bind for UAV (example - generating mipmaps in a compute shader)
            mUAVMipSlice: u16,
            /// Binds entire mip chain as array of UAV
            mBindMipChain: bool,
        };

        pub const __Struct2 = extern struct {
            /// Bind MTLIndirectCommandBuffer along with the MTLBuffer
            pICBName: [*c]const u8,
            mICBIndex: u32,
            mBindICB: bool,
        };
    };

    /// Array of resources containing descriptor handles or constant to be used in ring buffer memory - DescriptorRange can hold only one
    /// resource type array
    pub const __Union2 = extern union {
        /// Array of texture descriptors (srv and uav textures)
        ppTextures: [*c][*c]Texture,
        /// Array of sampler descriptors
        ppSamplers: [*c][*c]Sampler,
        /// Array of buffer descriptors (srv, uav and cbv buffers)
        ppBuffers: [*c][*c]Buffer,
        /// Custom binding (raytracing acceleration structure ...)
        ppAccelerationStructures: [*c]*AccelerationStructure,
    };
};

pub const DescriptorSet = extern struct {
    mDx: __Struct0,

    pub const __Struct0 = extern struct {
        /// Start handle to cbv srv uav descriptor table
        mCbvSrvUavHandle: DxDescriptorID,
        /// Start handle to sampler descriptor table
        mSamplerHandle: DxDescriptorID,
        /// Stride of the cbv srv uav descriptor table (number of descriptors * descriptor size)
        mCbvSrvUavStride: u32,
        /// Stride of the sampler descriptor table (number of descriptors * descriptor size)
        mSamplerStride: u32,
        pRootSignature: [*c]const RootSignature,
        bitfield_1: packed struct(u32) {
            mMaxSets: u16, // 16 bits
            mUpdateFrequency: u3, // 19 bits
            mNodeIndex: u4, // 23 bits
            mCbvSrvUavRootIndex: u4, // 27 bits
            mSamplerRootIndex: u4, // 31 bits
            /// Padding added by c2z
            _dummy_padding: u1,
        },

        bitfield_2: packed struct(u32) {
            mPipelineType: u3, // 3 bits
            /// Padding added by c2z
            _dummy_padding: u29,
        },
    };
};

pub const CmdPoolDesc = extern struct {
    pQueue: [*c]Queue,
    mTransient: bool,
};

pub const CmdPool = extern struct {
    pCmdAlloc: *ID3D12CommandAllocator,
    pQueue: [*c]Queue,
};

pub const CmdDesc = extern struct {
    pPool: [*c]CmdPool,
    mSecondary: bool,
    pName: [*c]const u8,
};

pub const MarkerType = extern struct {
    bits: c_int = 0,

    pub const MARKER_TYPE_DEFAULT: MarkerType = .{ .bits = @as(c_uint, @intCast(0)) };
    pub const MARKER_TYPE_IN: MarkerType = .{ .bits = @as(c_uint, @intCast(1)) };
    pub const MARKER_TYPE_OUT: MarkerType = .{ .bits = @as(c_uint, @intCast(2)) };
    pub const MARKER_TYPE_IN_OUT: MarkerType = .{ .bits = @as(c_uint, @intCast(3)) };

    // pub usingnamespace cpp.FlagsMixin(MarkerType);
};

pub const Cmd = extern struct {
    pRenderer: [*c]Renderer,
    pQueue: [*c]Queue,

    pub const __Struct0 = extern struct {
        pCmdList: *ID3D12GraphicsCommandList1,
        /// Cached in beginCmd to avoid fetching them during rendering
        pBoundHeaps: [2]*DescriptorHeap,
        mBoundHeapStartHandles: [2]D3D12_GPU_DESCRIPTOR_HANDLE,
        /// Command buffer state
        pBoundRootSignature: [*c]const RootSignature,
        pBoundDescriptorSets: [4][*c]DescriptorSet,
        mBoundDescriptorSetIndices: [4]u16,
        bitfield_1: packed struct(u32) {
            mNodeIndex: u4, // 4 bits
            mType: u3, // 7 bits
            /// Padding added by c2z
            _dummy_padding: u25,
        },

        pCmdPool: [*c]CmdPool,
    };
};

pub const FenceStatus = extern struct {
    bits: c_int = 0,

    pub const FENCE_STATUS_COMPLETE: FenceStatus = .{ .bits = @as(c_uint, @intCast(0)) };
    pub const FENCE_STATUS_INCOMPLETE: FenceStatus = .{ .bits = FenceStatus.FENCE_STATUS_COMPLETE.bits + 1 };
    pub const FENCE_STATUS_NOTSUBMITTED: FenceStatus = .{ .bits = FenceStatus.FENCE_STATUS_COMPLETE.bits + 2 };

    // pub usingnamespace cpp.FlagsMixin(FenceStatus);
};

pub const Fence = extern struct {
    mDx: __Struct0,

    pub const __Struct0 = extern struct {
        pFence: *ID3D12Fence,
        pWaitIdleFenceEvent: HANDLE,
        mFenceValue: u64,
    };
};

pub const Semaphore = extern struct {
    mDx: __Struct0,

    /// queuePresent does not use the wait semaphore since the swapchain Present function
    /// already does the synchronization in this case
    pub const __Struct0 = extern struct {
        pFence: *ID3D12Fence,
        pWaitIdleFenceEvent: HANDLE,
        mFenceValue: u64,
    };
};

pub const QueueDesc = extern struct {
    mType: QueueType,
    mFlag: QueueFlag,
    mPriority: QueuePriority,
    mNodeIndex: u32,
    pName: [*c]const u8,
};

pub const Queue = extern struct {
    mDx: __Struct0,
    bitfield_1: packed struct(u32) {
        mType: u3, // 3 bits
        mNodeIndex: u4, // 7 bits
        /// Padding added by c2z
        _dummy_padding: u25,
    },

    pub const __Struct0 = extern struct {
        pQueue: *ID3D12CommandQueue,
        pFence: [*c]Fence,
        /// To silence mismatching command list on Windows 11 multi GPU
        pRenderer: [*c]Renderer,
    };
};

/// ShaderConstant only supported by Vulkan and Metal APIs
pub const ShaderConstant = extern struct {
    pValue: ?*const anyopaque,
    mIndex: u32,
    mSize: u32,
};

/// ShaderConstant only supported by Vulkan and Metal APIs
pub const BinaryShaderStageDesc = extern struct {
    pName: [*c]const u8,
    /// Byte code array
    pByteCode: ?*anyopaque,
    mByteCodeSize: u32,
    pEntryPoint: [*c]const u8,
};

pub const BinaryShaderDesc = extern struct {
    mStages: ShaderStage,
    bitfield_1: packed struct(u32) {
        /// Specify whether shader will own byte code memory
        mOwnByteCode: u1, // 1 bits
        /// Padding added by c2z
        _dummy_padding: u31,
    },

    mVert: BinaryShaderStageDesc,
    mFrag: BinaryShaderStageDesc,
    mGeom: BinaryShaderStageDesc,
    mHull: BinaryShaderStageDesc,
    mDomain: BinaryShaderStageDesc,
    mComp: BinaryShaderStageDesc,
    pConstants: [*c]const ShaderConstant,
    mConstantCount: u32,
};

pub const Shader = extern struct {
    bitfield_1: packed struct(u32) {
        mStages: u31, // 31 bits
        /// C2Z WARNING: This perhaps shouldn't be padded in this way!
        /// Padding added by c2z
        _dummy_padding: u1,
    },

    bitfield_2: packed struct(u8) {
        mIsMultiviewVR: u1, // 1 bits
        /// Padding added by c2z
        _dummy_padding: u7,
    },

    mNumThreadsPerGroup: [3]u32,
    mOutputRenderTargetTypesMask: u32,
    mDx: __Struct0,
    pReflection: *PipelineReflection,

    pub const __Struct0 = extern struct {
        pShaderBlobs: [*c]*IDxcBlobEncoding,
        pEntryNames: [*c]LPCWSTR,
    };
};

pub const BlendStateDesc = extern struct {
    /// Source blend factor per render target.
    mSrcFactors: [8]BlendConstant,
    /// Destination blend factor per render target.
    mDstFactors: [8]BlendConstant,
    /// Source alpha blend factor per render target.
    mSrcAlphaFactors: [8]BlendConstant,
    /// Destination alpha blend factor per render target.
    mDstAlphaFactors: [8]BlendConstant,
    /// Blend mode per render target.
    mBlendModes: [8]BlendMode,
    /// Alpha blend mode per render target.
    mBlendAlphaModes: [8]BlendMode,
    /// Write mask per render target.
    mColorWriteMasks: [8]ColorMask,
    /// Mask that identifies the render targets affected by the blend state.
    mRenderTargetMask: BlendStateTargets,
    /// Set whether alpha to coverage should be enabled.
    mAlphaToCoverage: bool,
    /// Set whether each render target has an unique blend function. When false the blend function in slot 0 will be used for all render
    /// targets.
    mIndependentBlend: bool,
};

pub const DepthStateDesc = extern struct {
    mDepthTest: bool,
    mDepthWrite: bool,
    mDepthFunc: CompareMode,
    mStencilTest: bool,
    mStencilReadMask: u8,
    mStencilWriteMask: u8,
    mStencilFrontFunc: CompareMode,
    mStencilFrontFail: StencilOp,
    mDepthFrontFail: StencilOp,
    mStencilFrontPass: StencilOp,
    mStencilBackFunc: CompareMode,
    mStencilBackFail: StencilOp,
    mDepthBackFail: StencilOp,
    mStencilBackPass: StencilOp,
};

pub const RasterizerStateDesc = extern struct {
    mCullMode: CullMode,
    mDepthBias: i32,
    mSlopeScaledDepthBias: f32,
    mFillMode: FillMode,
    mFrontFace: FrontFace,
    mMultiSample: bool,
    mScissor: bool,
    mDepthClampEnable: bool,
};

pub const VertexBindingRate = extern struct {
    bits: c_int = 0,

    pub const VERTEX_BINDING_RATE_VERTEX: VertexBindingRate = .{ .bits = @as(c_uint, @intCast(0)) };
    pub const VERTEX_BINDING_RATE_INSTANCE: VertexBindingRate = .{ .bits = @as(c_uint, @intCast(1)) };
    pub const VERTEX_BINDING_RATE_COUNT: VertexBindingRate = .{ .bits = VertexBindingRate.VERTEX_BINDING_RATE_INSTANCE.bits + 1 };

    // pub usingnamespace cpp.FlagsMixin(VertexBindingRate);
};

pub const VertexBinding = extern struct {
    mStride: u32,
    mRate: VertexBindingRate,
};

pub const VertexAttrib = extern struct {
    mSemantic: ShaderSemantic,
    mSemanticNameLength: u32,
    mSemanticName: [128]u8,
    mFormat: TinyImageFormat,
    mBinding: u32,
    mLocation: u32,
    mOffset: u32,
};

pub const VertexLayout = extern struct {
    mBindings: [15]VertexBinding,
    mAttribs: [15]VertexAttrib,
    mBindingCount: u32,
    mAttribCount: u32,
};

pub const GraphicsPipelineDesc = extern struct {
    pShaderProgram: [*c]Shader,
    pRootSignature: [*c]RootSignature,
    pVertexLayout: [*c]VertexLayout,
    pBlendState: [*c]BlendStateDesc,
    pDepthState: [*c]DepthStateDesc,
    pRasterizerState: [*c]RasterizerStateDesc,
    pColorFormats: [*c]TinyImageFormat,
    mRenderTargetCount: u32,
    mSampleCount: SampleCount,
    mSampleQuality: u32,
    mDepthStencilFormat: TinyImageFormat,
    mPrimitiveTopo: PrimitiveTopology,
    mSupportIndirectCommandBuffer: bool,
    mVRFoveatedRendering: bool,
    mUseCustomSampleLocations: bool,
};

pub const ComputePipelineDesc = extern struct {
    pShaderProgram: [*c]Shader,
    pRootSignature: [*c]RootSignature,
};

pub const PipelineDesc = extern struct {
    __union_field1: __Union0,
    pCache: [*c]PipelineCache,
    pPipelineExtensions: ?*anyopaque,
    pName: [*c]const u8,
    mType: PipelineType,
    mExtensionCount: u32,

    pub const __Union0 = extern union {
        mComputeDesc: ComputePipelineDesc,
        mGraphicsDesc: GraphicsPipelineDesc,
    };
};

pub const Pipeline = extern struct {
    mDx: __Struct0,

    pub const __Struct0 = extern struct {
        pPipelineState: *ID3D12PipelineState,
        pRootSignature: [*c]const RootSignature,
        mType: PipelineType,
        mPrimitiveTopology: D3D_PRIMITIVE_TOPOLOGY,
    };
};

pub const PipelineCacheFlags = extern struct {
    bits: c_int = 0,

    pub const PIPELINE_CACHE_FLAG_NONE: PipelineCacheFlags = .{ .bits = @as(c_uint, @intCast(0)) };
    pub const PIPELINE_CACHE_FLAG_EXTERNALLY_SYNCHRONIZED: PipelineCacheFlags = .{ .bits = @as(c_uint, @intCast(1)) };

    // pub usingnamespace cpp.FlagsMixin(PipelineCacheFlags);
};

pub const PipelineCacheDesc = extern struct {
    /// Initial pipeline cache data (can be NULL which means empty pipeline cache)
    pData: ?*anyopaque,
    /// Initial pipeline cache size
    mSize: usize,
    mFlags: PipelineCacheFlags,
};

pub const PipelineCache = extern struct {
    mDx: __Struct0,

    pub const __Struct0 = extern struct {
        pLibrary: *ID3D12PipelineLibrary,
        pData: ?*anyopaque,
    };
};

pub const SwapChainCreationFlags = extern struct {
    bits: c_int = 0,

    pub const SWAP_CHAIN_CREATION_FLAG_NONE: SwapChainCreationFlags = .{ .bits = @as(c_uint, @intCast(0)) };
    pub const SWAP_CHAIN_CREATION_FLAG_ENABLE_FOVEATED_RENDERING_VR: SwapChainCreationFlags = .{ .bits = @as(c_uint, @intCast(1)) };

    // pub usingnamespace cpp.FlagsMixin(SwapChainCreationFlags);
};

pub const SwapChainDesc = extern struct {
    /// Window handle
    mWindowHandle: WindowHandle,
    /// Queues which should be allowed to present
    ppPresentQueues: [*c][*c]Queue,
    /// Number of present queues
    mPresentQueueCount: u32,
    /// Number of backbuffers in this swapchain
    mImageCount: u32,
    /// Width of the swapchain
    mWidth: u32,
    /// Height of the swapchain
    mHeight: u32,
    /// Color format of the swapchain
    mColorFormat: TinyImageFormat,
    /// Clear value
    mColorClearValue: ClearValue,
    /// Swapchain creation flags
    mFlags: SwapChainCreationFlags,
    /// Set whether swap chain will be presented using vsync
    mEnableVsync: bool,
    /// We can toggle to using FLIP model if app desires.
    mUseFlipSwapEffect: bool,
    /// Optional colorspace for HDR
    mColorSpace: ColorSpace,
};

pub const SwapChain = extern struct {
    /// Render targets created from the swapchain back buffers
    ppRenderTargets: [*c][*c]RenderTarget,
    mDx: __Struct0,
    bitfield_1: packed struct(u32) {
        mImageCount: u8, // 8 bits
        mEnableVsync: u1, // 9 bits
        mColorSpace: u4, // 13 bits
        mFormat: u8, // 21 bits
        /// Padding added by c2z
        _dummy_padding: u11,
    },

    pub const __Struct0 = extern struct {
        /// Use IDXGISwapChain3 for now since IDXGISwapChain4
        /// isn't supported by older devices.
        pSwapChain: *IDXGISwapChain3,
        bitfield_1: packed struct(u32) {
            /// Sync interval to specify how interval for vsync
            mSyncInterval: u3, // 3 bits
            mFlags: u10, // 13 bits
            /// Padding added by c2z
            _dummy_padding: u19,
        },
    };
};

pub const ShaderTarget = extern struct {
    bits: c_int = 0,

    /// 5.1 is supported on all DX12 hardware
    pub const SHADER_TARGET_5_1: ShaderTarget = .{ .bits = 0 };
    /// 5.1 is supported on all DX12 hardware
    pub const SHADER_TARGET_6_0: ShaderTarget = .{ .bits = 1 };
    /// 5.1 is supported on all DX12 hardware
    pub const SHADER_TARGET_6_1: ShaderTarget = .{ .bits = 2 };
    /// 5.1 is supported on all DX12 hardware
    pub const SHADER_TARGET_6_2: ShaderTarget = .{ .bits = 3 };
    /// required for Raytracing
    pub const SHADER_TARGET_6_3: ShaderTarget = .{ .bits = 4 };
    /// required for VRS
    pub const SHADER_TARGET_6_4: ShaderTarget = .{ .bits = 5 };
    pub const SHADER_TARGET_6_5: ShaderTarget = .{ .bits = 6 };
    ///required for Dynamic Resources
    pub const SHADER_TARGET_6_6: ShaderTarget = .{ .bits = 7 };

    // pub usingnamespace cpp.FlagsMixin(ShaderTarget);
};

pub const GpuMode = extern struct {
    bits: c_int = 0,

    pub const GPU_MODE_SINGLE: GpuMode = .{ .bits = @as(c_uint, @intCast(0)) };
    pub const GPU_MODE_LINKED: GpuMode = .{ .bits = GpuMode.GPU_MODE_SINGLE.bits + 1 };
    pub const GPU_MODE_UNLINKED: GpuMode = .{ .bits = GpuMode.GPU_MODE_SINGLE.bits + 2 };

    // pub usingnamespace cpp.FlagsMixin(GpuMode);
};

pub const ExtendedSettings = extern struct {
    mNumSettings: u32,
    pSettings: [*c]u32,
    ppSettingNames: [*c]const [*c]u8,
};

pub const RendererDesc = extern struct {
    mDx: __Struct0,
    mShaderTarget: ShaderTarget,
    mGpuMode: GpuMode,
    /// Apps may want to query additional state for their applications. That information is transferred through here.
    pExtendedSettings: [*c]ExtendedSettings,
    /// Required when creating unlinked multiple renderers. Optional otherwise, can be used for explicit GPU selection.
    pContext: [*c]RendererContext,
    mGpuIndex: u32,
    /// This results in new validation not possible during API calls on the CPU, by creating patched shaders that have validation added
    /// directly to the shader. However, it can slow things down a lot, especially for applications with numerous PSOs. Time to see the
    /// first render frame may take several minutes
    mEnableGpuBasedValidation: bool,
    mD3D11Supported: bool,
    mGLESSupported: bool,
    /// Also, if `ReloadServer` code is interfering with debugging (due to threads/networking), then it can be temporarily disabled via this
    /// flag. NOTE: This flag overrides the behaviour specified by the `EnableReloadServer` field.
    mDisableReloadServer: bool,

    pub const __Struct0 = extern struct {
        mFeatureLevel: D3D_FEATURE_LEVEL,
    };
};

pub const GPUVendorPreset = extern struct {
    mVendorId: u32,
    mModelId: u32,
    /// Optional as not all gpu's have that. Default is : 0x00
    mRevisionId: u32,
    mPresetLevel: GPUPresetLevel,
    mVendorName: [256]u8,
    /// If GPU Name is missing then value will be empty string
    mGpuName: [256]u8,
    mGpuDriverVersion: [256]u8,
    mGpuDriverDate: [256]u8,
    mRTCoresCount: u32,
};

pub const FormatCapability = extern struct {
    bits: c_int = 0,

    pub const FORMAT_CAP_NONE: FormatCapability = .{ .bits = @as(c_uint, @intCast(0)) };
    pub const FORMAT_CAP_LINEAR_FILTER: FormatCapability = .{ .bits = @as(c_uint, @intCast(1)) };
    pub const FORMAT_CAP_READ: FormatCapability = .{ .bits = @as(c_uint, @intCast(2)) };
    pub const FORMAT_CAP_WRITE: FormatCapability = .{ .bits = @as(c_uint, @intCast(4)) };
    pub const FORMAT_CAP_READ_WRITE: FormatCapability = .{ .bits = @as(c_uint, @intCast(8)) };
    pub const FORMAT_CAP_RENDER_TARGET: FormatCapability = .{ .bits = @as(c_uint, @intCast(16)) };

    // pub usingnamespace cpp.FlagsMixin(FormatCapability);
};

pub const GPUCapBits = extern struct {
    mFormatCaps: [239]FormatCapability,
};

pub const DefaultResourceAlignment = extern struct {
    bits: c_int = 0,

    pub const RESOURCE_BUFFER_ALIGNMENT: DefaultResourceAlignment = .{ .bits = 4 };

    // pub usingnamespace cpp.FlagsMixin(DefaultResourceAlignment);
};

pub const WaveOpsSupportFlags = extern struct {
    bits: c_int = 0,

    pub const WAVE_OPS_SUPPORT_FLAG_NONE: WaveOpsSupportFlags = .{ .bits = @as(c_uint, @intCast(0)) };
    pub const WAVE_OPS_SUPPORT_FLAG_BASIC_BIT: WaveOpsSupportFlags = .{ .bits = @as(c_uint, @intCast(1)) };
    pub const WAVE_OPS_SUPPORT_FLAG_VOTE_BIT: WaveOpsSupportFlags = .{ .bits = @as(c_uint, @intCast(2)) };
    pub const WAVE_OPS_SUPPORT_FLAG_ARITHMETIC_BIT: WaveOpsSupportFlags = .{ .bits = @as(c_uint, @intCast(4)) };
    pub const WAVE_OPS_SUPPORT_FLAG_BALLOT_BIT: WaveOpsSupportFlags = .{ .bits = @as(c_uint, @intCast(8)) };
    pub const WAVE_OPS_SUPPORT_FLAG_SHUFFLE_BIT: WaveOpsSupportFlags = .{ .bits = @as(c_uint, @intCast(16)) };
    pub const WAVE_OPS_SUPPORT_FLAG_SHUFFLE_RELATIVE_BIT: WaveOpsSupportFlags = .{ .bits = @as(c_uint, @intCast(32)) };
    pub const WAVE_OPS_SUPPORT_FLAG_CLUSTERED_BIT: WaveOpsSupportFlags = .{ .bits = @as(c_uint, @intCast(64)) };
    pub const WAVE_OPS_SUPPORT_FLAG_QUAD_BIT: WaveOpsSupportFlags = .{ .bits = @as(c_uint, @intCast(128)) };
    pub const WAVE_OPS_SUPPORT_FLAG_PARTITIONED_BIT_NV: WaveOpsSupportFlags = .{ .bits = @as(c_uint, @intCast(256)) };
    pub const WAVE_OPS_SUPPORT_FLAG_ALL: WaveOpsSupportFlags = .{ .bits = @as(c_uint, @intCast(2147483647)) };

    // pub usingnamespace cpp.FlagsMixin(WaveOpsSupportFlags);
};

/// update availableGpuProperties in GPUConfig.cpp if you made changes to this list
pub const GPUSettings = extern struct {
    /// set to 0 on OpenGLES platform
    mVRAM: u64,
    mUniformBufferAlignment: u32,
    mUploadBufferTextureAlignment: u32,
    mUploadBufferTextureRowAlignment: u32,
    mMaxVertexInputBindings: u32,
    mMaxRootSignatureDWORDS: u32,
    mWaveLaneCount: u32,
    mWaveOpsSupportFlags: WaveOpsSupportFlags,
    mGpuVendorPreset: GPUVendorPreset,
    mWaveOpsSupportedStageFlags: ShaderStage,
    mMaxTotalComputeThreads: u32,
    mMaxComputeThreads: [3]u32,
    bitfield_1: packed struct(u32) {
        mMultiDrawIndirect: u1, // 1 bits
        mIndirectRootConstant: u1, // 2 bits
        mBuiltinDrawID: u1, // 3 bits
        mIndirectCommandBuffer: u1, // 4 bits
        mROVsSupported: u1, // 5 bits
        mTessellationSupported: u1, // 6 bits
        mGeometryShaderSupported: u1, // 7 bits
        mGpuBreadcrumbs: u1, // 8 bits
        mHDRSupported: u1, // 9 bits
        mTimestampQueries: u1, // 10 bits
        mOcclusionQueries: u1, // 11 bits
        mPipelineStatsQueries: u1, // 12 bits
        mAllowBufferTextureInSameHeap: u1, // 13 bits
        mRaytracingSupported: u1, // 14 bits
        mRayPipelineSupported: u1, // 15 bits
        mRayQuerySupported: u1, // 16 bits
        mSoftwareVRSSupported: u1, // 17 bits
        mPrimitiveIdSupported: u1, // 18 bits
        /// Padding added by c2z
        _dummy_padding: u14,
    },

    mFeatureLevel: D3D_FEATURE_LEVEL,
    mMaxBoundTextures: u32,
    bitfield_2: packed struct(u32) {
        mSamplerAnisotropySupported: u1, // 1 bits
        mGraphicsQueueSupported: u1, // 2 bits
        /// Padding added by c2z
        _dummy_padding: u30,
    },

    mAmdAsicFamily: u32,
};

/// update availableGpuProperties in GPUConfig.cpp if you made changes to this list
pub const Renderer = extern struct {
    mDx: __Struct0,
    pNullDescriptors: *NullDescriptors,
    pContext: [*c]RendererContext,
    pGpu: [*c]const GpuInfo,
    pName: [*c]const u8,
    mRendererApi: RendererApi,
    bitfield_1: packed struct(u32) {
        mLinkedNodeCount: u4, // 4 bits
        mUnlinkedRendererIndex: u4, // 8 bits
        mGpuMode: u3, // 11 bits
        mShaderTarget: u4, // 15 bits
        mOwnsContext: u1, // 16 bits
        /// Padding added by c2z
        _dummy_padding: u16,
    },

    pub const __Struct0 = extern struct {
        /// API specific descriptor heap and memory allocator
        pCPUDescriptorHeaps: [*c]*DescriptorHeap,
        pCbvSrvUavHeaps: [*c]*DescriptorHeap,
        pSamplerHeaps: [*c]*DescriptorHeap,
        pResourceAllocator: *D3D12MAAllocator,
        pDevice: *ID3D12Device,
        pDebugValidation: *ID3D12InfoQueue,
        mSuppressMismatchingCommandListDuringPresent: bool,
    };

    // opaques

    const NullDescriptors = anyopaque;
};

pub const RendererContextDesc = extern struct {
    mDx: __Struct0,
    mEnableGpuBasedValidation: bool,
    mD3D11Supported: bool,
    mGLESSupported: bool,

    pub const __Struct0 = extern struct {
        mFeatureLevel: D3D_FEATURE_LEVEL,
    };
};

pub const GpuInfo = extern struct {
    mDx: __Struct0,
    mSettings: GPUSettings,
    mCapBits: GPUCapBits,

    pub const __Struct0 = extern struct {
        pGpu: *IDXGIAdapter4,
    };
};

pub const RendererContext = extern struct {
    mDx: __Struct0,
    mGpus: [4]GpuInfo,
    mGpuCount: u32,

    pub const __Struct0 = extern struct {
        pDXGIFactory: *IDXGIFactory6,
        pDebug: *ID3D12Debug,
    };
};

/// Indirect command structure define
pub const IndirectArgument = extern struct {
    mType: IndirectArgumentType,
    mOffset: u32,
};

/// Indirect command structure define
pub const IndirectArgumentDescriptor = extern struct {
    mType: IndirectArgumentType,
    mIndex: u32,
    mByteSize: u32,
};

pub const CommandSignatureDesc = extern struct {
    pRootSignature: [*c]RootSignature,
    pArgDescs: [*c]IndirectArgumentDescriptor,
    mIndirectArgCount: u32,
    /// Set to true if indirect argument struct should not be aligned to 16 bytes
    mPacked: bool,
};

pub const CommandSignature = extern struct {
    pHandle: *ID3D12CommandSignature,
    mDrawType: IndirectArgumentType,
    mStride: u32,
};

pub const DescriptorSetDesc = extern struct {
    pRootSignature: [*c]RootSignature,
    mUpdateFrequency: DescriptorUpdateFrequency,
    mMaxSets: u32,
    mNodeIndex: u32,
};

pub const QueueSubmitDesc = extern struct {
    ppCmds: [*c][*c]Cmd,
    pSignalFence: [*c]Fence,
    ppWaitSemaphores: [*c][*c]Semaphore,
    ppSignalSemaphores: [*c][*c]Semaphore,
    mCmdCount: u32,
    mWaitSemaphoreCount: u32,
    mSignalSemaphoreCount: u32,
    mSubmitDone: bool,
};

pub const QueuePresentDesc = extern struct {
    pSwapChain: [*c]SwapChain,
    ppWaitSemaphores: [*c][*c]Semaphore,
    mWaitSemaphoreCount: u32,
    mIndex: u8,
    mSubmitDone: bool,
};

pub const BindRenderTargetDesc = extern struct {
    pRenderTarget: [*c]RenderTarget,
    mLoadAction: LoadActionType,
    mStoreAction: StoreActionType,
    mClearValue: ClearValue,
    mLoadActionStencil: LoadActionType,
    mStoreActionStencil: StoreActionType,
    mArraySlice: u32,
    bitfield_1: packed struct(u32) {
        mMipSlice: u10, // 10 bits
        mOverrideClearValue: u1, // 11 bits
        mUseArraySlice: u1, // 12 bits
        mUseMipSlice: u1, // 13 bits
        /// Padding added by c2z
        _dummy_padding: u19,
    },
};

pub const BindDepthTargetDesc = extern struct {
    pDepthStencil: [*c]RenderTarget,
    mLoadAction: LoadActionType,
    mLoadActionStencil: LoadActionType,
    mStoreAction: StoreActionType,
    mStoreActionStencil: StoreActionType,
    mClearValue: ClearValue,
    mArraySlice: u32,
    bitfield_1: packed struct(u32) {
        mMipSlice: u10, // 10 bits
        mOverrideClearValue: u1, // 11 bits
        mUseArraySlice: u1, // 12 bits
        mUseMipSlice: u1, // 13 bits
        /// Padding added by c2z
        _dummy_padding: u19,
    },
};

pub const BindRenderTargetsDesc = extern struct {
    mRenderTargetCount: u32,
    mRenderTargets: [8]BindRenderTargetDesc,
    mDepthStencil: BindDepthTargetDesc,
    /// Explicit viewport for empty render pass
    mExtent: [2]u32,
};

extern fn _1_setRendererInitializationError_(reason: [*c]const u8) void;
/// clang-format off
/// Utilities functions
pub const setRendererInitializationError = _1_setRendererInitializationError_;

extern fn _1_hasRendererInitializationError_(outReason: [*c]const [*c]u8) bool;
pub const hasRendererInitializationError = _1_hasRendererInitializationError_;

extern fn _1_initRendererContext_(appName: [*c]const u8, pSettings: [*c]const RendererContextDesc, ppContext: [*c][*c]RendererContext) void;
/// Multiple renderer API (optional)
pub const initRendererContext = _1_initRendererContext_;

extern fn _1_exitRendererContext_(pContext: [*c]RendererContext) void;
pub const exitRendererContext = _1_exitRendererContext_;

extern fn _1_initRenderer_(appName: [*c]const u8, pSettings: [*c]const RendererDesc, ppRenderer: [*c][*c]Renderer) void;
/// allocates memory and initializes the renderer -> returns pRenderer
pub const initRenderer = _1_initRenderer_;

extern fn _1_exitRenderer_(pRenderer: [*c]Renderer) void;
pub const exitRenderer = _1_exitRenderer_;

extern fn _1_addFence(renderer: [*c]Renderer, fence: [*c][*c]Fence) void;
pub fn addFence(renderer: [*c]Renderer, fence: [*c][*c]Fence) void {
    _1_addFence(renderer, fence);
}

extern fn _1_removeFence(renderer: [*c]Renderer, fence: [*c]Fence) void;
pub fn removeFence(renderer: [*c]Renderer, fence: [*c]Fence) void {
    _1_removeFence(renderer, fence);
}

extern fn _1_addSemaphore(renderer: [*c]Renderer, semaphore: [*c][*c]Semaphore) void;
pub fn addSemaphore(renderer: [*c]Renderer, semaphore: [*c][*c]Semaphore) void {
    _1_addSemaphore(renderer, semaphore);
}

extern fn _1_removeSemaphore(renderer: [*c]Renderer, semaphore: [*c]Semaphore) void;
pub fn removeSemaphore(renderer: [*c]Renderer, semaphore: [*c]Semaphore) void {
    _1_removeSemaphore(renderer, semaphore);
}

extern fn _1_addQueue(renderer: [*c]Renderer, desc: [*c]QueueDesc, queue: [*c][*c]Queue) void;
pub fn addQueue(r: [*c]Renderer, qd: [*c]QueueDesc, q: [*c][*c]Queue) void {
    _1_addQueue(r, qd, q);
}

extern fn _1_removeQueue(renderer: [*c]Renderer, queue: [*c]Queue) void;
pub fn removeQueue(r: [*c]Renderer, q: [*c]Queue) void {
    _1_removeQueue(r, q);
}

extern fn _1_addSwapChain(renderer: [*c]Renderer, desc: [*c]const SwapChainDesc, swap_chain: [*c][*c]SwapChain) void;
pub fn addSwapChain(renderer: [*c]Renderer, desc: [*c]const SwapChainDesc, swap_chain: [*c][*c]SwapChain) void {
    _1_addSwapChain(renderer, desc, swap_chain);
}

extern fn _1_removeSwapChain(renderer: [*c]Renderer, swap_chain: [*c]SwapChain) void;
pub fn removeSwapChain(renderer: [*c]Renderer, swap_chain: [*c]SwapChain) void {
    _1_removeSwapChain(renderer, swap_chain);
}

pub const addResourceHeapFn = ?*const fn ([*c]Renderer, [*c]const ResourceHeapDesc, [*c][*c]ResourceHeap) callconv(.C) void;

extern var _1_addResourceHeap_: *addResourceHeapFn;
pub const addResourceHeap = _1_addResourceHeap_;

pub const removeResourceHeapFn = ?*const fn ([*c]Renderer, [*c]ResourceHeap) callconv(.C) void;

extern var _1_removeResourceHeap_: *removeResourceHeapFn;
pub const removeResourceHeap = _1_removeResourceHeap_;

extern fn _1_addCmdPool(renderer: [*c]Renderer, desc: [*c]const CmdPoolDesc, cmd_pool: [*c][*c]CmdPool) void;
pub fn addCmdPool(renderer: [*c]Renderer, desc: [*c]const CmdPoolDesc, cmd_pool: [*c][*c]CmdPool) void {
    _1_addCmdPool(renderer, desc, cmd_pool);
}

extern fn _1_removeCmdPool(renderer: [*c]Renderer, cmd_pool: [*c]CmdPool) void;
pub fn removeCmdPool(renderer: [*c]Renderer, cmd_pool: [*c]CmdPool) void {
    _1_removeCmdPool(renderer, cmd_pool);
}

extern fn _1_addCmd(renderer: [*c]Renderer, desc: [*c]const CmdDesc, cmd: [*c][*c]Cmd) void;
pub fn addCmd(renderer: [*c]Renderer, desc: [*c]const CmdDesc, cmd: [*c][*c]Cmd) void {
    _1_addCmd(renderer, desc, cmd);
}

extern fn _1_removeCmd(renderer: [*c]Renderer, cmd: [*c]Cmd) void;
pub fn removeCmd(renderer: [*c]Renderer, cmd: [*c]Cmd) void {
    _1_removeCmd(renderer, cmd);
}

pub const addCmd_nFn = ?*const fn ([*c]Renderer, [*c]const CmdDesc, u32, [*c][*c][*c]Cmd) callconv(.C) void;

extern var _1_addCmd_n_: *addCmd_nFn;
pub const addCmd_n = _1_addCmd_n_;

pub const removeCmd_nFn = ?*const fn ([*c]Renderer, u32, [*c][*c]Cmd) callconv(.C) void;

extern var _1_removeCmd_n_: *removeCmd_nFn;
pub const removeCmd_n = _1_removeCmd_n_;

extern fn _1_addRenderTarget(renderer: [*c]Renderer, desc: [*c]const RenderTargetDesc, render_target: [*c][*c]RenderTarget) void;
pub fn addRenderTarget(renderer: [*c]Renderer, desc: [*c]const RenderTargetDesc, render_target: [*c][*c]RenderTarget) void {
    _1_addRenderTarget(renderer, desc, render_target);
}

extern fn _1_removeRenderTarget(renderer: [*c]Renderer, render_target: [*c]RenderTarget) void;
pub fn removeRenderTarget(renderer: [*c]Renderer, render_target: [*c]RenderTarget) void {
    _1_removeRenderTarget(renderer, render_target);
}

pub const addSamplerFn = ?*const fn ([*c]Renderer, [*c]const SamplerDesc, [*c][*c]Sampler) callconv(.C) void;

extern fn _1_addSampler(_: [*c]Renderer, _: [*c]const SamplerDesc, _: [*c][*c]Sampler) void;
pub fn addSampler(renderer: [*c]Renderer, desc: [*c]const SamplerDesc, sampler: [*c][*c]Sampler) void {
    _1_addSampler(renderer, desc, sampler);
}

pub const removeSamplerFn = ?*const fn ([*c]Renderer, [*c]Sampler) callconv(.C) void;

extern fn _1_removeSampler(renderer: [*c]Renderer, sampler: [*c]Sampler) void;
pub fn removeSampler(renderer: [*c]Renderer, sampler: [*c]Sampler) void {
    _1_removeSampler(renderer, sampler);
}

pub const addShaderBinaryFn = ?*const fn ([*c]Renderer, [*c]const BinaryShaderDesc, [*c][*c]Shader) callconv(.C) void;

extern var _1_addShaderBinary_: *addShaderBinaryFn;
pub const addShaderBinary = _1_addShaderBinary_;

extern fn _1_removeShader(renderer: [*c]Renderer, shader: [*c]Shader) void;
pub fn removeShader(renderer: [*c]Renderer, shader: [*c]Shader) void {
    _1_removeShader(renderer, shader);
}

extern fn _1_addRootSignature(renderer: [*c]Renderer, desc: [*c]const RootSignatureDesc, root_signature: [*c][*c]RootSignature) void;
pub fn addRootSignature(renderer: [*c]Renderer, desc: [*c]const RootSignatureDesc, root_signature: [*c][*c]RootSignature) void {
    _1_addRootSignature(renderer, desc, root_signature);
}

extern fn _1_removeRootSignature(renderer: [*c]Renderer, root_signature: [*c]RootSignature) void;
pub fn removeRootSignature(renderer: [*c]Renderer, root_signature: [*c]RootSignature) void {
    _1_removeRootSignature(renderer, root_signature);
}

extern fn _1_getDescriptorIndexFromName(root_signature: [*c]const RootSignature, name: [*c]const u8) u32;
pub fn getDescriptorIndexFromName(root_signature: [*c]const RootSignature, name: [*c]const u8) u32 {
    return _1_getDescriptorIndexFromName(root_signature, name);
}

extern fn _1_addPipeline(renderer: [*c]Renderer, desc: [*c]const PipelineDesc, pipeline: [*c][*c]Pipeline) void;
pub fn addPipeline(renderer: [*c]Renderer, desc: [*c]const PipelineDesc, pipeline: [*c][*c]Pipeline) void {
    _1_addPipeline(renderer, desc, pipeline);
}

extern fn _1_removePipeline(renderer: [*c]Renderer, pipeline: [*c]Pipeline) void;
pub fn removePipeline(renderer: [*c]Renderer, pipeline: [*c]Pipeline) void {
    _1_removePipeline(renderer, pipeline);
}

pub const addPipelineCacheFn = ?*const fn ([*c]Renderer, [*c]const PipelineCacheDesc, [*c][*c]PipelineCache) callconv(.C) void;

extern var _1_addPipelineCache_: *addPipelineCacheFn;
pub const addPipelineCache = _1_addPipelineCache_;

pub const getPipelineCacheDataFn = ?*const fn ([*c]Renderer, [*c]PipelineCache, [*c]usize, ?*anyopaque) callconv(.C) void;

extern var _1_getPipelineCacheData_: *getPipelineCacheDataFn;
pub const getPipelineCacheData = _1_getPipelineCacheData_;

pub const removePipelineCacheFn = ?*const fn ([*c]Renderer, [*c]PipelineCache) callconv(.C) void;

extern var _1_removePipelineCache_: *removePipelineCacheFn;
pub const removePipelineCache = _1_removePipelineCache_;

extern fn _1_addDescriptorSet(renderer: [*c]Renderer, desc: [*c]const DescriptorSetDesc, descriptor_sets: [*c][*c]DescriptorSet) void;
pub fn addDescriptorSet(renderer: [*c]Renderer, desc: [*c]const DescriptorSetDesc, descriptor_sets: [*c][*c]DescriptorSet) void {
    _1_addDescriptorSet(renderer, desc, descriptor_sets);
}

extern fn _1_removeDescriptorSet(renderer: [*c]Renderer, descriptor_set: [*c]DescriptorSet) void;
pub fn removeDescriptorSet(renderer: [*c]Renderer, descriptor_set: [*c]DescriptorSet) void {
    _1_removeDescriptorSet(renderer, descriptor_set);
}

extern fn _1_updateDescriptorSet(renderer: [*c]Renderer, index: u32, descriptor_set: [*c]DescriptorSet, count: u32, params: [*c]const DescriptorData) void;
pub fn updateDescriptorSet(renderer: [*c]Renderer, index: u32, descriptor_set: [*c]DescriptorSet, count: u32, params: [*c]const DescriptorData) void {
    _1_updateDescriptorSet(renderer, index, descriptor_set, count, params);
}

extern fn _1_resetCmdPool(renderer: [*c]Renderer, cmd_pool: [*c]CmdPool) void;
pub fn resetCmdPool(renderer: [*c]Renderer, cmd_pool: [*c]CmdPool) void {
    _1_resetCmdPool(renderer, cmd_pool);
}

extern fn _1_beginCmd(cmd: [*c]Cmd) void;
pub fn beginCmd(cmd: [*c]Cmd) void {
    _1_beginCmd(cmd);
}

extern fn _1_endCmd(cmd: [*c]Cmd) void;
pub fn endCmd(cmd: [*c]Cmd) void {
    _1_endCmd(cmd);
}

extern fn _1_cmdBindRenderTargets(cmd: [*c]Cmd, desc: [*c]const BindRenderTargetsDesc) void;
pub fn cmdBindRenderTargets(cmd: [*c]Cmd, desc: [*c]const BindRenderTargetsDesc) void {
    _1_cmdBindRenderTargets(cmd, desc);
}

pub const cmdSetSampleLocationsFn = ?*const fn ([*c]Cmd, SampleCount, u32, u32, [*c]SampleLocations) callconv(.C) void;

extern var _1_cmdSetSampleLocations_: *cmdSetSampleLocationsFn;
pub const cmdSetSampleLocations = _1_cmdSetSampleLocations_;

pub const cmdSetViewportFn = ?*const fn ([*c]Cmd, f32, f32, f32, f32, f32, f32) callconv(.C) void;

extern fn _1_cmdSetViewport(cmd: [*c]Cmd, x: f32, y: f32, width: f32, height: f32, min_depth: f32, max_depth: f32) void;
pub fn cmdSetViewport(cmd: [*c]Cmd, x: f32, y: f32, width: f32, height: f32, min_depth: f32, max_depth: f32) void {
    _1_cmdSetViewport(cmd, x, y, width, height, min_depth, max_depth);
}

extern fn _1_cmdSetScissor(cmd: [*c]Cmd, x: u32, y: u32, width: u32, height: u32) void;
pub fn cmdSetScissor(cmd: [*c]Cmd, x: u32, y: u32, width: u32, height: u32) void {
    _1_cmdSetScissor(cmd, x, y, width, height);
}

pub const cmdSetStencilReferenceValueFn = ?*const fn ([*c]Cmd, u32) callconv(.C) void;

extern var _1_cmdSetStencilReferenceValue_: *cmdSetStencilReferenceValueFn;
pub const cmdSetStencilReferenceValue = _1_cmdSetStencilReferenceValue_;

extern fn _1_cmdBindPipeline(cmd_list: [*c]Cmd, pipeline: [*c]Pipeline) void;
pub fn cmdBindPipeline(cmd_list: [*c]Cmd, pipeline: [*c]Pipeline) void {
    _1_cmdBindPipeline(cmd_list, pipeline);
}

extern fn _1_cmdBindDescriptorSet(cmd: [*c]Cmd, index: u32, descriptor_set: [*c]DescriptorSet) void;
pub fn cmdBindDescriptorSet(cmd: [*c]Cmd, index: u32, descriptor_set: [*c]DescriptorSet) void {
    _1_cmdBindDescriptorSet(cmd, index, descriptor_set);
}

extern fn _1_cmdBindPushConstants(cmd_list: [*c]Cmd, root_signature: [*c]RootSignature, param_index: u32, constants: ?*const anyopaque) void;
pub fn cmdBindPushConstants(cmd_list: [*c]Cmd, root_signature: [*c]RootSignature, param_index: u32, constants: ?*const anyopaque) void {
    _1_cmdBindPushConstants(cmd_list, root_signature, param_index, constants);
}

pub const cmdBindDescriptorSetWithRootCbvsFn = ?*const fn ([*c]Cmd, u32, [*c]DescriptorSet, u32, [*c]const DescriptorData) callconv(.C) void;

extern var _1_cmdBindDescriptorSetWithRootCbvs_: *cmdBindDescriptorSetWithRootCbvsFn;
pub const cmdBindDescriptorSetWithRootCbvs = _1_cmdBindDescriptorSetWithRootCbvs_;

extern fn _1_cmdBindIndexBuffer(cmd_list: [*c]Cmd, buffer: [*c]Buffer, index_type: u32, offset: u64) void;
pub fn cmdBindIndexBuffer(cmd_list: [*c]Cmd, buffer: [*c]Buffer, index_type: u32, offset: u64) void {
    _1_cmdBindIndexBuffer(cmd_list, buffer, index_type, offset);
}

extern fn _1_cmdBindVertexBuffer(cmd_list: [*c]Cmd, buffer_count: u32, buffers: [*c][*c]Buffer, strides: [*c]const u32, offsets: [*c]const u64) void;
pub fn cmdBindVertexBuffer(cmd_list: [*c]Cmd, buffer_count: u32, buffers: [*c][*c]Buffer, strides: [*c]const u32, offsets: [*c]const u64) void {
    _1_cmdBindVertexBuffer(cmd_list, buffer_count, buffers, strides, offsets);
}

extern fn _1_cmdDraw(cmd_list: [*c]Cmd, vertex_count: u32, first_vertex: u32) void;
pub fn cmdDraw(cmd_list: [*c]Cmd, vertex_count: u32, first_vertex: u32) void {
    _1_cmdDraw(cmd_list, vertex_count, first_vertex);
}

pub const cmdDrawInstancedFn = ?*const fn ([*c]Cmd, u32, u32, u32, u32) callconv(.C) void;

extern var _1_cmdDrawInstanced_: *cmdDrawInstancedFn;
pub const cmdDrawInstanced = _1_cmdDrawInstanced_;

extern fn _1_cmdDrawIndexed(cmd_list: [*c]Cmd, index_count: u32, first_index: u32, first_vertex: u32) void;
pub fn cmdDrawIndexed(cmd_list: [*c]Cmd, index_count: u32, first_index: u32, first_vertex: u32) void {
    _1_cmdDrawIndexed(cmd_list, index_count, first_index, first_vertex);
}

extern fn _1_cmdDrawIndexedInstanced(cmd_list: [*c]Cmd, index_count: u32, first_index: u32, instance_count: u32, first_vertex: u32, first_instance: u32) void;
pub fn cmdDrawIndexedInstanced(cmd_list: [*c]Cmd, index_count: u32, first_index: u32, instance_count: u32, first_vertex: u32, first_instance: u32) void {
    _1_cmdDrawIndexedInstanced(cmd_list, index_count, first_index, instance_count, first_vertex, first_instance);
}

extern fn _1_cmdDispatch(cmd_list: [*c]Cmd, group_count_x: u32, group_count_y: u32, group_count_z: u32) void;
pub fn cmdDispatch(cmd_list: [*c]Cmd, group_count_x: u32, group_count_y: u32, group_count_z: u32) void {
    _1_cmdDispatch(cmd_list, group_count_x, group_count_y, group_count_z);
}

extern fn _1_cmdResourceBarrier(cmd: [*c]Cmd, buffer_barrier_count: u32, buffer_barrier: [*c]BufferBarrier, texture_barrier_count: u32, texture_barrier: [*c]TextureBarrier, render_target_barrier_count: u32, render_target_barrier: [*c]RenderTargetBarrier) void;
pub fn cmdResourceBarrier(cmd: [*c]Cmd, buffer_barrier_count: u32, buffer_barrier: [*c]BufferBarrier, texture_barrier_count: u32, texture_barrier: [*c]TextureBarrier, render_target_barrier_count: u32, render_target_barrier: [*c]RenderTargetBarrier) void {
    _1_cmdResourceBarrier(cmd, buffer_barrier_count, buffer_barrier, texture_barrier_count, texture_barrier, render_target_barrier_count, render_target_barrier);
}

extern fn _1_acquireNextImage(renderer: [*c]Renderer, swap_chain: [*c]SwapChain, semaphore: [*c]Semaphore, fence: [*c]Fence, index: [*c]u32) void;
pub fn acquireNextImage(renderer: [*c]Renderer, swap_chain: [*c]SwapChain, semaphore: [*c]Semaphore, fence: [*c]Fence, index: [*c]u32) void {
    _1_acquireNextImage(renderer, swap_chain, semaphore, fence, index);
}

extern fn _1_queueSubmit(queue: [*c]Queue, desc: [*c]const QueueSubmitDesc) void;
pub fn queueSubmit(queue: [*c]Queue, desc: [*c]const QueueSubmitDesc) void {
    _1_queueSubmit(queue, desc);
}

extern fn _1_queuePresent(queue: [*c]Queue, desc: [*c]const QueuePresentDesc) void;
pub fn queuePresent(queue: [*c]Queue, desc: [*c]const QueuePresentDesc) void {
    _1_queuePresent(queue, desc);
}

extern fn _1_waitQueueIdle(queue: [*c]Queue) void;
pub fn waitQueueIdle(queue: [*c]Queue) void {
    _1_waitQueueIdle(queue);
}

extern fn _1_getFenceStatus(renderer: [*c]Renderer, fence: [*c]Fence, status: [*c]FenceStatus) void;
pub fn getFenceStatus(renderer: [*c]Renderer, fence: [*c]Fence, status: [*c]FenceStatus) void {
    _1_getFenceStatus(renderer, fence, status);
}

extern fn _1_waitForFences(renderer: [*c]Renderer, count: u32, fences: [*c][*c]Fence) void;
pub fn waitForFences(renderer: [*c]Renderer, count: u32, fences: [*c][*c]Fence) void {
    _1_waitForFences(renderer, count, fences);
}

pub const toggleVSyncFn = ?*const fn ([*c]Renderer, [*c][*c]SwapChain) callconv(.C) void;

extern var _1_toggleVSync_: *toggleVSyncFn;
pub const toggleVSync = _1_toggleVSync_;

pub const getSupportedSwapchainFormatFn = ?*const fn ([*c]Renderer, [*c]const SwapChainDesc, ColorSpace) callconv(.C) TinyImageFormat;

extern fn _1_getSupportedSwapchainFormat(renderer: [*c]Renderer, desc: [*c]const SwapChainDesc, color_space: ColorSpace) TinyImageFormat;
pub fn getSupportedSwapchainFormat(renderer: [*c]Renderer, desc: [*c]const SwapChainDesc, color_space: ColorSpace) TinyImageFormat {
    return _1_getSupportedSwapchainFormat(renderer, desc, color_space);
}

pub const getRecommendedSwapchainImageCountFn = ?*const fn ([*c]Renderer, [*c]const WindowHandle) callconv(.C) u32;

extern fn _1_getRecommendedSwapchainImageCount(renderer: [*c]Renderer, window_handle: [*c]const WindowHandle) u32;
pub fn getRecommendedSwapchainImageCount(renderer: [*c]Renderer, window_handle: [*c]const WindowHandle) u32 {
    return _1_getRecommendedSwapchainImageCount(renderer, window_handle);
}

pub const addIndirectCommandSignatureFn = ?*const fn ([*c]Renderer, [*c]const CommandSignatureDesc, [*c][*c]CommandSignature) callconv(.C) void;

extern var _1_addIndirectCommandSignature_: *addIndirectCommandSignatureFn;
pub const addIndirectCommandSignature = _1_addIndirectCommandSignature_;

pub const removeIndirectCommandSignatureFn = ?*const fn ([*c]Renderer, [*c]CommandSignature) callconv(.C) void;

extern var _1_removeIndirectCommandSignature_: *removeIndirectCommandSignatureFn;
pub const removeIndirectCommandSignature = _1_removeIndirectCommandSignature_;

pub const cmdExecuteIndirectFn = ?*const fn ([*c]Cmd, [*c]CommandSignature, c_uint, [*c]Buffer, u64, [*c]Buffer, u64) callconv(.C) void;

extern var _1_cmdExecuteIndirect_: *cmdExecuteIndirectFn;
pub const cmdExecuteIndirect = _1_cmdExecuteIndirect_;

pub const getTimestampFrequencyFn = ?*const fn ([*c]Queue, [*c]f64) callconv(.C) void;

extern var _1_getTimestampFrequency_: *getTimestampFrequencyFn;
pub const getTimestampFrequency = _1_getTimestampFrequency_;

pub const addQueryPoolFn = ?*const fn ([*c]Renderer, [*c]const QueryPoolDesc, [*c][*c]QueryPool) callconv(.C) void;

extern var _1_addQueryPool_: *addQueryPoolFn;
pub const addQueryPool = _1_addQueryPool_;

pub const removeQueryPoolFn = ?*const fn ([*c]Renderer, [*c]QueryPool) callconv(.C) void;

extern var _1_removeQueryPool_: *removeQueryPoolFn;
pub const removeQueryPool = _1_removeQueryPool_;

pub const cmdBeginQueryFn = ?*const fn ([*c]Cmd, [*c]QueryPool, [*c]QueryDesc) callconv(.C) void;

extern var _1_cmdBeginQuery_: *cmdBeginQueryFn;
pub const cmdBeginQuery = _1_cmdBeginQuery_;

pub const cmdEndQueryFn = ?*const fn ([*c]Cmd, [*c]QueryPool, [*c]QueryDesc) callconv(.C) void;

extern var _1_cmdEndQuery_: *cmdEndQueryFn;
pub const cmdEndQuery = _1_cmdEndQuery_;

pub const cmdResolveQueryFn = ?*const fn ([*c]Cmd, [*c]QueryPool, u32, u32) callconv(.C) void;

extern var _1_cmdResolveQuery_: *cmdResolveQueryFn;
pub const cmdResolveQuery = _1_cmdResolveQuery_;

pub const cmdResetQueryFn = ?*const fn ([*c]Cmd, [*c]QueryPool, u32, u32) callconv(.C) void;

extern var _1_cmdResetQuery_: *cmdResetQueryFn;
pub const cmdResetQuery = _1_cmdResetQuery_;

pub const getQueryDataFn = ?*const fn ([*c]Renderer, [*c]QueryPool, u32, [*c]QueryData) callconv(.C) void;

extern var _1_getQueryData_: *getQueryDataFn;
pub const getQueryData = _1_getQueryData_;

pub const calculateMemoryStatsFn = ?*const fn ([*c]Renderer, [*c][*c]u8) callconv(.C) void;

extern var _1_calculateMemoryStats_: *calculateMemoryStatsFn;
pub const calculateMemoryStats = _1_calculateMemoryStats_;

pub const calculateMemoryUseFn = ?*const fn ([*c]Renderer, [*c]u64, [*c]u64) callconv(.C) void;

extern var _1_calculateMemoryUse_: *calculateMemoryUseFn;
pub const calculateMemoryUse = _1_calculateMemoryUse_;

pub const freeMemoryStatsFn = ?*const fn ([*c]Renderer, [*c]u8) callconv(.C) void;

extern var _1_freeMemoryStats_: *freeMemoryStatsFn;
pub const freeMemoryStats = _1_freeMemoryStats_;

pub const cmdBeginDebugMarkerFn = ?*const fn ([*c]Cmd, f32, f32, f32, [*c]const u8) callconv(.C) void;

extern var _1_cmdBeginDebugMarker_: *cmdBeginDebugMarkerFn;
pub const cmdBeginDebugMarker = _1_cmdBeginDebugMarker_;

pub const cmdEndDebugMarkerFn = ?*const fn ([*c]Cmd) callconv(.C) void;

extern var _1_cmdEndDebugMarker_: *cmdEndDebugMarkerFn;
pub const cmdEndDebugMarker = _1_cmdEndDebugMarker_;

pub const cmdAddDebugMarkerFn = ?*const fn ([*c]Cmd, f32, f32, f32, [*c]const u8) callconv(.C) void;

extern var _1_cmdAddDebugMarker_: *cmdAddDebugMarkerFn;
pub const cmdAddDebugMarker = _1_cmdAddDebugMarker_;

pub const cmdWriteMarkerFn = ?*const fn ([*c]Cmd, MarkerType, u32, [*c]Buffer, usize, bool) callconv(.C) u32;

extern var _1_cmdWriteMarker_: *cmdWriteMarkerFn;
pub const cmdWriteMarker = _1_cmdWriteMarker_;

pub const setBufferNameFn = ?*const fn ([*c]Renderer, [*c]Buffer, [*c]const u8) callconv(.C) void;

extern var _1_setBufferName_: *setBufferNameFn;
pub const setBufferName = _1_setBufferName_;

pub const setTextureNameFn = ?*const fn ([*c]Renderer, [*c]Texture, [*c]const u8) callconv(.C) void;

extern var _1_setTextureName_: *setTextureNameFn;
pub const setTextureName = _1_setTextureName_;

pub const setRenderTargetNameFn = ?*const fn ([*c]Renderer, [*c]RenderTarget, [*c]const u8) callconv(.C) void;

extern var _1_setRenderTargetName_: *setRenderTargetNameFn;
pub const setRenderTargetName = _1_setRenderTargetName_;

pub const setPipelineNameFn = ?*const fn ([*c]Renderer, [*c]Pipeline, [*c]const u8) callconv(.C) void;

extern var _1_setPipelineName_: *setPipelineNameFn;
pub const setPipelineName = _1_setPipelineName_;

// opaques

const D3D12MAAllocator = anyopaque;
const D3D12MAAllocation = anyopaque;
const AccelerationStructure = anyopaque;
const RaytracingHitGroup = anyopaque;
const DescriptorIndexMap = anyopaque;
const Raytracing = anyopaque;
const EsramManager = anyopaque;

// unnamed nodes

pub const UnnamedEnum0 = extern struct {
    bits: c_int = 0,

    pub const MAX_INSTANCE_EXTENSIONS: UnnamedEnum0 = .{ .bits = @as(c_uint, @intCast(64)) };
    pub const MAX_DEVICE_EXTENSIONS: UnnamedEnum0 = .{ .bits = @as(c_uint, @intCast(64)) };
    /// Max number of GPUs in SLI or Cross-Fire
    pub const MAX_LINKED_GPUS: UnnamedEnum0 = .{ .bits = @as(c_uint, @intCast(4)) };
    /// Max number of GPUs in unlinked mode
    pub const MAX_UNLINKED_GPUS: UnnamedEnum0 = .{ .bits = @as(c_uint, @intCast(4)) };
    /// Max number of GPus for either linked or unlinked mode. must update WindowsBase::setupPlatformUI accordingly
    pub const MAX_MULTIPLE_GPUS: UnnamedEnum0 = .{ .bits = @as(c_uint, @intCast(4)) };
    /// Max number of GPus for either linked or unlinked mode. must update WindowsBase::setupPlatformUI accordingly
    pub const MAX_RENDER_TARGET_ATTACHMENTS: UnnamedEnum0 = .{ .bits = @as(c_uint, @intCast(8)) };
    /// Max number of GPus for either linked or unlinked mode. must update WindowsBase::setupPlatformUI accordingly
    pub const MAX_VERTEX_BINDINGS: UnnamedEnum0 = .{ .bits = @as(c_uint, @intCast(15)) };
    /// Max number of GPus for either linked or unlinked mode. must update WindowsBase::setupPlatformUI accordingly
    pub const MAX_VERTEX_ATTRIBS: UnnamedEnum0 = .{ .bits = @as(c_uint, @intCast(15)) };
    /// Max number of GPus for either linked or unlinked mode. must update WindowsBase::setupPlatformUI accordingly
    pub const MAX_RESOURCE_NAME_LENGTH: UnnamedEnum0 = .{ .bits = @as(c_uint, @intCast(256)) };
    /// Max number of GPus for either linked or unlinked mode. must update WindowsBase::setupPlatformUI accordingly
    pub const MAX_SEMANTIC_NAME_LENGTH: UnnamedEnum0 = .{ .bits = @as(c_uint, @intCast(128)) };
    /// Max number of GPus for either linked or unlinked mode. must update WindowsBase::setupPlatformUI accordingly
    pub const MAX_DEBUG_NAME_LENGTH: UnnamedEnum0 = .{ .bits = @as(c_uint, @intCast(128)) };
    /// Max number of GPus for either linked or unlinked mode. must update WindowsBase::setupPlatformUI accordingly
    pub const MAX_MIP_LEVELS: UnnamedEnum0 = .{ .bits = 4294967295 };
    /// Max number of GPus for either linked or unlinked mode. must update WindowsBase::setupPlatformUI accordingly
    pub const MAX_SWAPCHAIN_IMAGES: UnnamedEnum0 = .{ .bits = @as(c_uint, @intCast(3)) };
    /// max size for GPUVendorPreset strings
    pub const MAX_GPU_VENDOR_STRING_LENGTH: UnnamedEnum0 = .{ .bits = @as(c_uint, @intCast(256)) };
    pub const MAX_SAMPLE_LOCATIONS: UnnamedEnum0 = .{ .bits = @as(c_uint, @intCast(16)) };

    // pub usingnamespace cpp.FlagsMixin(UnnamedEnum0);
};
