// auto generated by c2z
const std = @import("std");
//const cpp = @import("cpp");

const time_t = i64;

pub const ResourceMount = extern struct {
    bits: c_int = 0,

    /// Installed game directory / bundle resource directory
    pub const RM_CONTENT: ResourceMount = .{ .bits = @as(c_uint, @intCast(0)) };
    /// For storing debug data such as log files. To be used only during development
    pub const RM_DEBUG: ResourceMount = .{ .bits = ResourceMount.RM_CONTENT.bits + 1 };
    /// Documents directory
    pub const RM_DOCUMENTS: ResourceMount = .{ .bits = ResourceMount.RM_CONTENT.bits + 2 };
    /// Save game data mount 0
    pub const RM_SAVE_0: ResourceMount = .{ .bits = ResourceMount.RM_CONTENT.bits + 3 };
    pub const RM_COUNT: ResourceMount = .{ .bits = ResourceMount.RM_CONTENT.bits + 4 };

    // pub usingnamespace cpp.FlagsMixin(ResourceMount);
};

pub const ResourceDirectory = extern struct {
    bits: c_int = 0,

    /// The main application's shader binaries directory
    pub const RD_SHADER_BINARIES: ResourceDirectory = .{ .bits = @as(c_uint, @intCast(0)) };
    /// The main application's shader binaries directory
    pub const RD_PIPELINE_CACHE: ResourceDirectory = .{ .bits = ResourceDirectory.RD_SHADER_BINARIES.bits + 1 };
    /// The main application's texture source directory (TODO processed texture folder)
    pub const RD_TEXTURES: ResourceDirectory = .{ .bits = ResourceDirectory.RD_SHADER_BINARIES.bits + 2 };
    /// The main application's texture source directory (TODO processed texture folder)
    pub const RD_COMPILED_MATERIALS: ResourceDirectory = .{ .bits = ResourceDirectory.RD_SHADER_BINARIES.bits + 3 };
    /// The main application's texture source directory (TODO processed texture folder)
    pub const RD_MESHES: ResourceDirectory = .{ .bits = ResourceDirectory.RD_SHADER_BINARIES.bits + 4 };
    /// The main application's texture source directory (TODO processed texture folder)
    pub const RD_FONTS: ResourceDirectory = .{ .bits = ResourceDirectory.RD_SHADER_BINARIES.bits + 5 };
    /// The main application's texture source directory (TODO processed texture folder)
    pub const RD_ANIMATIONS: ResourceDirectory = .{ .bits = ResourceDirectory.RD_SHADER_BINARIES.bits + 6 };
    /// The main application's texture source directory (TODO processed texture folder)
    pub const RD_AUDIO: ResourceDirectory = .{ .bits = ResourceDirectory.RD_SHADER_BINARIES.bits + 7 };
    /// The main application's texture source directory (TODO processed texture folder)
    pub const RD_GPU_CONFIG: ResourceDirectory = .{ .bits = ResourceDirectory.RD_SHADER_BINARIES.bits + 8 };
    /// The main application's texture source directory (TODO processed texture folder)
    pub const RD_LOG: ResourceDirectory = .{ .bits = ResourceDirectory.RD_SHADER_BINARIES.bits + 9 };
    /// The main application's texture source directory (TODO processed texture folder)
    pub const RD_SCRIPTS: ResourceDirectory = .{ .bits = ResourceDirectory.RD_SHADER_BINARIES.bits + 10 };
    /// The main application's texture source directory (TODO processed texture folder)
    pub const RD_SCREENSHOTS: ResourceDirectory = .{ .bits = ResourceDirectory.RD_SHADER_BINARIES.bits + 11 };
    /// The main application's texture source directory (TODO processed texture folder)
    pub const RD_DEBUG: ResourceDirectory = .{ .bits = ResourceDirectory.RD_SHADER_BINARIES.bits + 12 };
    pub const RD_OTHER_FILES: ResourceDirectory = .{ .bits = ResourceDirectory.RD_SHADER_BINARIES.bits + 13 };
    /// Libraries can have their own directories.
    /// Up to 100 libraries are supported.
    pub const ____rd_lib_counter_begin: ResourceDirectory = .{ .bits = @as(c_uint, @intCast(ResourceDirectory.RD_OTHER_FILES.bits + 1)) };
    /// Add libraries here
    pub const RD_MIDDLEWARE_0: ResourceDirectory = .{ .bits = @as(c_uint, @intCast(ResourceDirectory.____rd_lib_counter_begin.bits)) };
    /// Add libraries here
    pub const RD_MIDDLEWARE_1: ResourceDirectory = .{ .bits = ResourceDirectory.RD_MIDDLEWARE_0.bits + 1 };
    /// Add libraries here
    pub const RD_MIDDLEWARE_2: ResourceDirectory = .{ .bits = ResourceDirectory.RD_MIDDLEWARE_0.bits + 2 };
    /// Add libraries here
    pub const RD_MIDDLEWARE_3: ResourceDirectory = .{ .bits = ResourceDirectory.RD_MIDDLEWARE_0.bits + 3 };
    /// Add libraries here
    pub const RD_MIDDLEWARE_4: ResourceDirectory = .{ .bits = ResourceDirectory.RD_MIDDLEWARE_0.bits + 4 };
    /// Add libraries here
    pub const RD_MIDDLEWARE_5: ResourceDirectory = .{ .bits = ResourceDirectory.RD_MIDDLEWARE_0.bits + 5 };
    /// Add libraries here
    pub const RD_MIDDLEWARE_6: ResourceDirectory = .{ .bits = ResourceDirectory.RD_MIDDLEWARE_0.bits + 6 };
    /// Add libraries here
    pub const RD_MIDDLEWARE_7: ResourceDirectory = .{ .bits = ResourceDirectory.RD_MIDDLEWARE_0.bits + 7 };
    /// Add libraries here
    pub const RD_MIDDLEWARE_8: ResourceDirectory = .{ .bits = ResourceDirectory.RD_MIDDLEWARE_0.bits + 8 };
    /// Add libraries here
    pub const RD_MIDDLEWARE_9: ResourceDirectory = .{ .bits = ResourceDirectory.RD_MIDDLEWARE_0.bits + 9 };
    /// Add libraries here
    pub const RD_MIDDLEWARE_10: ResourceDirectory = .{ .bits = ResourceDirectory.RD_MIDDLEWARE_0.bits + 10 };
    /// Add libraries here
    pub const RD_MIDDLEWARE_11: ResourceDirectory = .{ .bits = ResourceDirectory.RD_MIDDLEWARE_0.bits + 11 };
    /// Add libraries here
    pub const RD_MIDDLEWARE_12: ResourceDirectory = .{ .bits = ResourceDirectory.RD_MIDDLEWARE_0.bits + 12 };
    /// Add libraries here
    pub const RD_MIDDLEWARE_13: ResourceDirectory = .{ .bits = ResourceDirectory.RD_MIDDLEWARE_0.bits + 13 };
    /// Add libraries here
    pub const RD_MIDDLEWARE_14: ResourceDirectory = .{ .bits = ResourceDirectory.RD_MIDDLEWARE_0.bits + 14 };
    /// Add libraries here
    pub const RD_MIDDLEWARE_15: ResourceDirectory = .{ .bits = ResourceDirectory.RD_MIDDLEWARE_0.bits + 15 };
    /// Add libraries here
    pub const ____rd_lib_counter_end: ResourceDirectory = .{ .bits = @as(c_uint, @intCast(ResourceDirectory.____rd_lib_counter_begin.bits + 99 * 2)) };
    /// Add libraries here
    pub const RD_COUNT: ResourceDirectory = .{ .bits = ResourceDirectory.____rd_lib_counter_end.bits + 1 };

    // pub usingnamespace cpp.FlagsMixin(ResourceDirectory);
};

pub const SeekBaseOffset = extern struct {
    bits: c_int = 0,

    pub const SBO_START_OF_FILE: SeekBaseOffset = .{ .bits = @as(c_uint, @intCast(0)) };
    pub const SBO_CURRENT_POSITION: SeekBaseOffset = .{ .bits = SeekBaseOffset.SBO_START_OF_FILE.bits + 1 };
    pub const SBO_END_OF_FILE: SeekBaseOffset = .{ .bits = SeekBaseOffset.SBO_START_OF_FILE.bits + 2 };

    // pub usingnamespace cpp.FlagsMixin(SeekBaseOffset);
};

pub const FileMode = extern struct {
    bits: c_int = 0,

    /// Get read access for file. Error if file not exist.
    pub const FM_READ: FileMode = .{ .bits = @as(c_uint, @intCast(1 << 0)) };
    /// Get write access for file. File is created if not exist.
    pub const FM_WRITE: FileMode = .{ .bits = @as(c_uint, @intCast(1 << 1)) };
    /// Set initial seek position to the end of file.
    pub const FM_APPEND: FileMode = .{ .bits = @as(c_uint, @intCast(1 << 2)) };
    /// Read access for other processes.
    /// Note: flag is required for Windows
    ///&Xbox
    ///.
    ///       On other platforms read access is always available.
    pub const FM_ALLOW_READ: FileMode = .{ .bits = @as(c_uint, @intCast(1 << 4)) };
    /// RW mode
    pub const FM_READ_WRITE: FileMode = .{ .bits = @as(c_uint, @intCast(FileMode.FM_READ.bits | FileMode.FM_WRITE.bits)) };
    /// W mode and set position to the end
    pub const FM_WRITE_APPEND: FileMode = .{ .bits = @as(c_uint, @intCast(FileMode.FM_WRITE.bits | FileMode.FM_APPEND.bits)) };
    /// R mode and set position to the end
    pub const FM_READ_APPEND: FileMode = .{ .bits = @as(c_uint, @intCast(FileMode.FM_READ.bits | FileMode.FM_APPEND.bits)) };
    /// RW mode and set position to the end
    pub const FM_READ_WRITE_APPEND: FileMode = .{ .bits = @as(c_uint, @intCast(FileMode.FM_READ.bits | FileMode.FM_APPEND.bits)) };
    /// -- mode and -- and also read access for other processes.
    pub const FM_WRITE_ALLOW_READ: FileMode = .{ .bits = @as(c_uint, @intCast(FileMode.FM_WRITE.bits | FileMode.FM_ALLOW_READ.bits)) };
    /// -- mode and -- and also read access for other processes.
    pub const FM_READ_WRITE_ALLOW_READ: FileMode = .{ .bits = @as(c_uint, @intCast(FileMode.FM_READ_WRITE.bits | FileMode.FM_ALLOW_READ.bits)) };
    /// -- mode and -- and also read access for other processes.
    pub const FM_WRITE_APPEND_ALLOW_READ: FileMode = .{ .bits = @as(c_uint, @intCast(FileMode.FM_WRITE_APPEND.bits | FileMode.FM_ALLOW_READ.bits)) };
    /// -- mode and -- and also read access for other processes.
    pub const FM_READ_WRITE_APPEND_ALLOW_READ: FileMode = .{ .bits = @as(c_uint, @intCast(FileMode.FM_READ_WRITE_APPEND.bits | FileMode.FM_ALLOW_READ.bits)) };

    // pub usingnamespace cpp.FlagsMixin(FileMode);
};

pub const FileStreamUserData = extern struct {
    data: [6]usize,
};

/// After stream is opened, only FileStream::pIO must be used for this stream.
/// Example:
///   io->Open(
///&stream
///); // stream is opened
///   io->Read(
///&stream
///, ...); // bug, potentially uses wrong io on wrong stream.
///   stream.pIO->Read(
///&stream
///, ...); // correct
/// The reason for this is that IFileSystem::Open can open stream using another
/// IFileSystem handle.
///
/// It is best to use IFileSystem IO shortcuts "fsReadFromStream(&stream,...)"
pub const FileStream = extern struct {
    pIO: [*c]IFileSystem,
    mMode: FileMode,
    mMount: ResourceMount,
    /// access to this field is IO exclusive
    mUser: FileStreamUserData,
};

/// After stream is opened, only FileStream::pIO must be used for this stream.
/// Example:
///   io->Open(
///&stream
///); // stream is opened
///   io->Read(
///&stream
///, ...); // bug, potentially uses wrong io on wrong stream.
///   stream.pIO->Read(
///&stream
///, ...); // correct
/// The reason for this is that IFileSystem::Open can open stream using another
/// IFileSystem handle.
///
/// It is best to use IFileSystem IO shortcuts "fsReadFromStream(&stream,...)"
pub const FileSystemInitDesc = extern struct {
    pAppName: [*c]const u8,
    pPlatformData: ?*anyopaque,
    pResourceMounts: [4][*c]const u8,
};

pub const IFileSystem = extern struct {
    Open: ?*const fn ([*c]IFileSystem, ResourceDirectory, [*c]const u8, FileMode, [*c]FileStream) callconv(.C) bool,
    /// Closes and invalidates the file stream.
    Close: ?*const fn ([*c]FileStream) callconv(.C) bool,
    /// Returns the number of bytes read.
    Read: ?*const fn ([*c]FileStream, ?*anyopaque, usize) callconv(.C) usize,
    /// Reads at most `bufferSizeInBytes` bytes from sourceBuffer and writes them into the file.
    /// Returns the number of bytes written.
    Write: ?*const fn ([*c]FileStream, ?*const anyopaque, usize) callconv(.C) usize,
    /// Seeks to the specified position in the file, using `baseOffset` as the reference offset.
    Seek: ?*const fn ([*c]FileStream, SeekBaseOffset, isize) callconv(.C) bool,
    /// Gets the current seek position in the file.
    GetSeekPosition: ?*const fn ([*c]FileStream) callconv(.C) isize,
    /// Gets the current size of the file. Returns -1 if the size is unknown or unavailable.
    GetFileSize: ?*const fn ([*c]FileStream) callconv(.C) isize,
    /// Flushes all writes to the file stream to the underlying subsystem.
    Flush: ?*const fn ([*c]FileStream) callconv(.C) bool,
    /// Returns whether the current seek position is at the end of the file stream.
    IsAtEnd: ?*const fn ([*c]FileStream) callconv(.C) bool,
    GetResourceMount: ?*const fn (ResourceMount) callconv(.C) [*c]const u8,
    /// Acquire unique file identifier.
    /// Only Archive FS supports it currently.
    GetFileUid: ?*const fn ([*c]IFileSystem, ResourceDirectory, [*c]const u8, [*c]u64) callconv(.C) bool,
    /// Open file using unique identifier. Use GetFileUid to get uid.
    OpenByUid: ?*const fn ([*c]IFileSystem, u64, FileMode, [*c]FileStream) callconv(.C) bool,
    /// Creates virtual address space of file.
    /// When memory mapping is done, file can be accessed just like an array.
    /// This is more efficient than using "FILE" stream.
    /// Not all platforms are supported.
    /// Use fsStreamWrapMemoryMap for strong cross-platform compatibility.
    /// This function does read-only memory map.
    MemoryMap: ?*const fn ([*c]FileStream, [*c]usize, [*c]const ?*anyopaque) callconv(.C) bool,
    pUser: ?*anyopaque,
};

// extern var _1_pSystemFileIO_: *[*c]IFileSystem;
// pub const pSystemFileIO = _1_pSystemFileIO_;
pub fn getSystemFileIO() [*c]IFileSystem {
    return _1_getSystemFileIO();
}
extern fn _1_getSystemFileIO() [*c]IFileSystem;

///*********************************************************************
///
/// MARK: - Initialization
///*********************************************************************
///
/// Initializes the FileSystem API
pub extern fn initFileSystem(pDesc: [*c]FileSystemInitDesc) bool;
/// Frees resources associated with the FileSystem API
pub extern fn exitFileSystem() void;

pub extern fn fsGetSystemFileIO() [*c]IFileSystem;
///*********************************************************************
///
/// MARK: - Archive file system
///*********************************************************************
pub const ArchiveOpenDesc = extern struct {
    /// Binary search "strcmp" is used as an alternative to hash table.
    /// Increases archive opening speed and decreases used memory.
    /// Useful if user won't resolve filenames (GetFileUid, Open),
    /// and will use UIDs instead (OpenByUid).
    disableHashTable: bool,
    /// Enable validation features, e.g.
    ///      hashtable verification
    ///      file name normalization
    ///
    /// If issues are found, archive fs can fix them most of the times.
    /// If validation is disabled, those issues are left undetected.
    ///
    /// Always enabled with FORGE_DEBUG macro.
    ///
    /// Use it for developer tools. Don't use it for shipping.
    validation: bool,
    /// Makes archive stream thread-safe
    /// It allows to read several files from archive asynchronously.
    /// Not used for fsArchiveOpenFromMemory
    ///
    /// Allows: (if this flag is set)
    /// Thread1: reads file "A"
    /// Thread2: reads file "B"
    ///
    /// Does not allow: (do not do this)
    /// Thread1: reads file "A"
    /// Thread2: reads file "A"
    protectStreamCriticalSection: bool,
    /// Do not log errors if archive header is wrong
    /// Set this flag if your thoughts are:
    /// "lets try to open file and see if this is an archive or not"
    tryMode: bool,
    /// Try to memory map stream using fsStreamMemoryMap
    mmap: bool,
};

/// 'desc' can be NULL
pub extern fn fsArchiveOpen(rd: ResourceDirectory, fileName: [*c]const u8, desc: [*c]const ArchiveOpenDesc, out: [*c]IFileSystem) bool;
/// This function is useful to use arbitrary stream source as an archive stream.
/// Only (*Seek) and (*Read) functions are required.
///
/// 'desc' can be NULL
/// 'stream' is owned by user, must be valid until fsArchiveClose
///          do not use stream while archive is opened
pub extern fn fsArchiveOpenFromStream(stream: [*c]FileStream, desc: [*c]const ArchiveOpenDesc, out: [*c]IFileSystem) bool;
/// Archive can be opened on "read from memory" mode.
/// Benifits:
/// - no need for ArchiveOpenDesc::protectStreamCriticalSection
/// - no filesystem overhead
/// - less buffering during decompression
///
/// Recommended for mmap-ed memory.
///
/// 'desc' can be NULL
/// 'm' is owned by user, must be valid until fsArchiveClose
pub extern fn fsArchiveOpenFromMemory(msize: u64, m: ?*const anyopaque, desc: [*c]const ArchiveOpenDesc, out: [*c]IFileSystem) bool;
pub extern fn fsArchiveClose(pArchive: [*c]IFileSystem) bool;
/// Opens the file at `filePath` using the mode `mode`, returning a new FileStream that can be used
/// to read from or modify the file. May return NULL if the file could not be opened.
pub extern fn fsOpenStreamFromPath(resourceDir: ResourceDirectory, fileName: [*c]const u8, mode: FileMode, pOut: [*c]FileStream) bool;
/// Opens a memory buffer as a FileStream, returning a stream that must be closed with `fsCloseStream`.
/// Use 'fsStreamMemoryMap' to do the opposite.
pub extern fn fsOpenStreamFromMemory(buffer: ?*const anyopaque, bufferSize: usize, mode: FileMode, owner: bool, pOut: [*c]FileStream) bool;
pub extern fn fsFindStream(fs: [*c]FileStream, pFind: ?*const anyopaque, findSize: usize, maxSeek: isize, pPosition: [*c]isize) bool;
pub extern fn fsFindReverseStream(fs: [*c]FileStream, pFind: ?*const anyopaque, findSize: usize, maxSeek: isize, pPosition: [*c]isize) bool;
/// Checks if stream is a standard system stream
pub extern fn fsIsSystemFileStream(fs: [*c]FileStream) bool;
/// Checks if stream is a memory stream
pub extern fn fsIsMemoryStream(fs: [*c]FileStream) bool;
/// symbolsCount can be SIZE_MAX, then reads until the end of file
/// appends '
///\
///0' to the end of string
pub extern fn fsReadBstringFromStream(stream: [*c]FileStream, pStr: [*c]bstring, symbolsCount: usize) usize;
/// Wraps stream into new memory stream using fsStreamMemoryMap
/// returns true: old stream is wrapped by new one with new IO.
/// returns false: stream is unaffected.
/// In both cases stream stays in valid state.
/// fsCloseStream(FileStream*) takes care of cleaning wrapped stream.
/// So checking return value is optional.
pub extern fn fsStreamWrapMemoryMap(fs: [*c]FileStream) bool;
extern fn _1_fsIoOpenStreamFromPath_(pIO: [*c]IFileSystem, rd: ResourceDirectory, fileName: [*c]const u8, mode: FileMode, pOut: [*c]FileStream) bool;
///*********************************************************************
///
/// MARK: - IFileSystem IO shortcuts
///*********************************************************************
pub const fsIoOpenStreamFromPath = _1_fsIoOpenStreamFromPath_;

extern fn _1_fsCloseStream_(fs: [*c]FileStream) bool;
/// Closes and invalidates the file stream.
pub const fsCloseStream = _1_fsCloseStream_;

extern fn _1_fsReadFromStream_(fs: [*c]FileStream, pOutputBuffer: ?*anyopaque, bufferSizeInBytes: usize) usize;
/// Returns the number of bytes read.
pub const fsReadFromStream = _1_fsReadFromStream_;

extern fn _1_fsWriteToStream_(fs: [*c]FileStream, pSourceBuffer: ?*const anyopaque, byteCount: usize) usize;
/// Reads at most `bufferSizeInBytes` bytes from sourceBuffer and writes them into the file.
/// Returns the number of bytes written.
pub const fsWriteToStream = _1_fsWriteToStream_;

extern fn _1_fsSeekStream_(fs: [*c]FileStream, baseOffset: SeekBaseOffset, seekOffset: isize) bool;
/// Seeks to the specified position in the file, using `baseOffset` as the reference offset.
pub const fsSeekStream = _1_fsSeekStream_;

extern fn _1_fsGetStreamSeekPosition_(fs: [*c]FileStream) isize;
/// Gets the current seek position in the file.
pub const fsGetStreamSeekPosition = _1_fsGetStreamSeekPosition_;

extern fn _1_fsGetStreamFileSize_(fs: [*c]FileStream) isize;
/// Gets the current size of the file. Returns -1 if the size is unknown or unavailable.
pub const fsGetStreamFileSize = _1_fsGetStreamFileSize_;

extern fn _1_fsFlushStream_(fs: [*c]FileStream) bool;
/// Flushes all writes to the file stream to the underlying subsystem.
pub const fsFlushStream = _1_fsFlushStream_;

extern fn _1_fsStreamAtEnd_(fs: [*c]FileStream) bool;
/// Returns whether the current seek position is at the end of the file stream.
pub const fsStreamAtEnd = _1_fsStreamAtEnd_;

pub inline fn fsIoGetResourceMount(pIO: [*c]IFileSystem, mount: ResourceMount) [*c]const u8 {
    if (!pIO.GetResourceMount != null) return &"\"\"";
    return pIO.GetResourceMount(mount);
}
pub inline fn fsIoGetFileUid(pIO: [*c]IFileSystem, rd: ResourceDirectory, fileName: [*c]const u8, outUid: [*c]u64) bool {
    if (!pIO.GetFileUid != null) return false;
    return pIO.GetFileUid(pIO, rd, fileName, outUid);
}
pub inline fn fsIoOpenByUid(pIO: [*c]IFileSystem, index: u64, mode: FileMode, pOutStream: [*c]FileStream) bool {
    if (!pIO.OpenByUid != null) return false;
    return pIO.OpenByUid(pIO, index, mode, pOutStream);
}
pub inline fn fsStreamMemoryMap(fs: [*c]FileStream, outSize: [*c]usize, outData: [*c]const ?*anyopaque) bool {
    if (!fs.pIO.MemoryMap != null) return false;
    return fs.pIO.MemoryMap(fs, outSize, outData);
}
///*********************************************************************
///
/// MARK: - Directory queries
///*********************************************************************
///
/// Returns location set for resource directory in fsSetPathForResourceDir.
pub extern fn fsGetResourceDirectory(resourceDir: ResourceDirectory) [*c]const u8;
/// Returns Resource Mount point for resource directory
pub extern fn fsGetResourceDirectoryMount(resourceDir: ResourceDirectory) ResourceMount;
/// Sets the relative path for `resourceDir` from `mount` to `bundledFolder`.
/// The `resourceDir` will making use of the given IFileSystem `pIO` file functions.
/// When `mount` is set to `RM_CONTENT` for a `resourceDir`, this directory is marked as a bundled resource folder.
/// Bundled resource folders should only be used for Read operations.
/// NOTE: A `resourceDir` can only be set once.
pub extern fn fsSetPathForResourceDir(pIO: [*c]IFileSystem, mount: ResourceMount, resourceDir: ResourceDirectory, bundledFolder: [*c]const u8) void;
/// Gets the time of last modification for the file at `fileName`, within 'resourceDir'.
pub extern fn fsGetLastModifiedTime(resourceDir: ResourceDirectory, fileName: [*c]const u8) time_t;
///*********************************************************************
///
/// MARK: - Platform-dependent function definitions
///*********************************************************************
pub extern fn fsCreateResourceDirectory(resourceDir: ResourceDirectory) bool;
/// Buny Archive File structure description:
/// First bytes are BunyArHeader with magic values and metadata location pointers
/// Metadata consist of following units:
///    archive nodes (file entries)
///    block of utf8 strings, referenced by nodes
///    precomputed hash table (optional)
///
/// Archive node contains file location within archive and other details
///
/// Archive supports several compression formats.
pub const BunyArFileFormat = extern struct {
    bits: c_int = 0,

    pub const BUNYAR_FILE_FORMAT_RAW: BunyArFileFormat = .{ .bits = @as(c_uint, @intCast(0)) };
    /// File is splitted to N X-size blocks.
    /// Leading data in a "blocks" format is represented by
    /// BunyArBlockFormatHeader and BunyArBlockPointer table.
    /// Table allows to seek through file quickly, while block size
    /// is large enough for compression to be effective.
    pub const BUNYAR_FILE_FORMAT_LZ4_BLOCKS: BunyArFileFormat = .{ .bits = @as(c_uint, @intCast(3)) };
    /// File is splitted to N X-size blocks.
    /// Leading data in a "blocks" format is represented by
    /// BunyArBlockFormatHeader and BunyArBlockPointer table.
    /// Table allows to seek through file quickly, while block size
    /// is large enough for compression to be effective.
    pub const BUNYAR_FILE_FORMAT_ZSTD_BLOCKS: BunyArFileFormat = .{ .bits = @as(c_uint, @intCast(5)) };

    // pub usingnamespace cpp.FlagsMixin(BunyArFileFormat);
};

extern const _1_BUNYAR_MAGIC_: *const [16]u8;
pub const BUNYAR_MAGIC = _1_BUNYAR_MAGIC_;

/// points to location within archive
pub const BunyArPointer64 = extern struct {
    /// exact offset
    offset: u64,
    /// exact size
    size: u64,
};

/// points to relative location
pub const BunyArPointer32 = extern struct {
    /// relative offset
    offset: u32,
    /// exact size
    size: u32,
};

/// Reader can still use archive,
/// if condition "compatible <= X <= actual" is met, where X is reader version.
pub const BunyArVersion = extern struct {
    /// backwards compatible version
    compatible: u32,
    /// archive version
    actual: u32,
};

pub const BunyArHeader = extern struct {
    /// ARCHIVE_MAGIC
    magic: [16]u8,
    version: BunyArVersion,
    /// 0, reserved
    flags: u64,
    /// nodeCount = nodesPointer.size / sizeof(BunyArNode)
    nodesPointer: BunyArPointer64,
    /// required size > 0 if nodesPoinster.size > 0
    /// size of 0 allowed for archive without entries
    namesPointer: BunyArPointer64,
    /// Location of BunyArHashTable.
    /// Hash table present, if size >= sizeof(BunyArHashTable)
    hashTablePointer: BunyArPointer64,
};

pub const BunyArNode = extern struct {
    /// BunyArFileFormat
    format: u64,
    /// Original size of file compressed into an archive.
    /// Also exact size of the file after reading from an archive
    originalFileSize: u64,
    /// location of name relative to location of BunyArHeader::namesPointer
    /// name is utf8 null-terminated string
    /// size must not count trailing 0
    /// size must be
    ///<
    ///= BUNYAR_FILE_NAME_LENGTH_MAX
    namePointer: BunyArPointer32,
    /// location of compressed file
    filePointer: BunyArPointer64,
};

pub const BunyArBlockFormatHeader = extern struct {
    /// size of all uncompressed blocks except the last one
    blockSize: u64,
    /// size of the last block. Strict rule: "blockSizeLast <= blockSize"
    blockSizeLast: u64,
    /// number of BunyArBlockPointer
    blockCount: u64,
};

pub const BunyArBlockPointer = u64;

pub const BunyArBlockInfo = extern struct {
    isCompressed: bool,
    /// size of compressed block in archive
    /// uncompressed size is equal to blockSize or blockSizeLast
    size: u32,
    /// block offset relative to the end of blockPointers
    offset: u64,
};

// syntax errors:
// pub inline fn bunyArDecodeBlockPointer(ptr: BunyArBlockPointer) BunyArBlockInfo {
// var info: BunyArBlockInfo = ;
// info.isCompressed = (((ptr & @as(BunyArBlockPointer, @intCast(1)))) != 0);
// info.size = (@as(u32, @intCast((ptr >> 41))) & ((@as(u32, @intCast(1)) << 23) - @as(u32, @intCast(1))));
// info.offset = ((ptr >> 1) & ((@as(u64, @intCast(1)) << 40) - @as(u64, @intCast(1))));
// info.size += @as(u32, @intCast(1));
// return ;
// }
//
pub inline fn bunyArEncodeBlockPointer(info: BunyArBlockInfo, dst: [*c]BunyArBlockPointer) bool {
    info.size -= @as(u32, @intCast(1));
    if (info.offset > ((@as(u64, @intCast(1)) << 40) - @as(u64, @intCast(1))) or info.size > ((@as(u32, @intCast(1)) << 23) - @as(u32, @intCast(1)))) return false;
    dst.* = (@as(u64, @intCast(info.isCompressed))) | (info.offset << 1) | (@as(u64, @intCast(info.size)) << 41);
    return true;
}
pub const BunyArHashTable = extern struct {
    /// 0 "magic" for later
    reserved: u64,
    seed: u64,
    tableSlotCount: u64,
};

/// user must deallocate returned pointer using tf_free
pub extern fn bunyArHashTableConstruct(nodeCount: u64, nodes: [*c]const BunyArNode, nodeNames: [*c]const u8) [*c]BunyArHashTable;
/// In case value >= nodeCount is returned, node by that name is not found
pub extern fn bunyArHashTableLookup(ht: [*c]const BunyArHashTable, name: [*c]const u8, nodeCount: u64, nodes: [*c]const BunyArNode, nodeNames: [*c]const u8) u64;
pub inline fn bunyArHashTableSize(ht: [*c]const BunyArHashTable) u64 {
    return if (ht != null) ht.tableSlotCount * @as(u64, @intCast(8)) + @sizeOf(ht.*) else @as(c_ulonglong, @intCast(0));
}
///*********************************************************************
///
/// MARK: - Advanced Buny Archive file system IO
///*********************************************************************
pub const BunyArDescription = extern struct {
    nodeCount: u64,
    hashTable: [*c]const BunyArHashTable,
};

pub const BunyArNodeDescription = extern struct {
    name: [*c]const u8,
    fileSize: u64,
    compressedSize: u64,
    format: BunyArFileFormat,
};

pub extern fn bunyArFormatName(format: BunyArFileFormat) [*c]const u8;
pub extern fn fsArchiveGetDescription(pArchive: [*c]IFileSystem, outInfo: [*c]BunyArDescription) void;
pub extern fn fsArchiveGetNodeDescription(pArchive: [*c]IFileSystem, nodeId: u64, outInfo: [*c]BunyArNodeDescription) bool;
/// Same as GetFileUid(), but without fileName postprocessing.
/// Uses fileName directly without resolving through ResourceDirectory
/// to search for file node.
pub extern fn fsArchiveGetNodeId(fs: [*c]IFileSystem, fileName: [*c]const u8, outUid: [*c]u64) bool;
pub extern fn fsArchiveGetFileBlockMetadata(pFile: [*c]FileStream, outHeader: [*c]BunyArBlockFormatHeader, outBlockPtrs: [*c]const [*c]BunyArBlockPointer) bool;

// opaques

const bstring = anyopaque;
